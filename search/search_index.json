{"config":{"lang":["en","es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"faucet","text":"<p>Fast, Asynchronous, Concurrent R and Python Application Deployment</p>"},{"location":"#overview","title":"Overview","text":"<p>Welcome to faucet, your high-performance solution for deploying Plumber APIs, Shiny Applications, and FastAPI applications with speed and efficiency. Faucet is a Rust-based server that offers Round Robin, IP Hash and Cookie Hash load balancing, ensuring seamless scaling and distribution of your R and Python applications. It also allows running arbitrary R and Python scripts. Whether you're a data scientist, developer, or DevOps enthusiast, faucet simplifies deployment, making it easy to manage replicas and balance loads effectively.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>High Performance: faucet leverages Rust's speed for smooth and efficient execution of R and Python applications.</li> <li>Polyglot Support: Natively deploy applications written in R (Plumber, Shiny) and Python (FastAPI), or run arbitrary <code>Rscript</code> and Python (<code>uv</code>) scripts.</li> <li>Load Balancing: Choose Round Robin, IP Hash or Cookie Hash load balancing for optimal resource utilization.</li> <li>Replicas: Scale Plumber APIs, Shiny Applications, and FastAPI applications effortlessly with multiple replicas.</li> <li>Simplified Deployment: faucet streamlines the deployment process for quick setup.</li> <li>Asynchronous &amp; Concurrent: Utilizes asynchronous and concurrent processing for resource efficiency and responsive request handling.</li> <li>Structured Event Tracing: Gain deep insights into your Shiny applications with detailed, machine-readable logs stored directly in your database.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>For installation options, refer to Installation.</p>"},{"location":"#usage","title":"Usage","text":"<p>For detailed usage instructions, refer to Getting Started.</p>"},{"location":"#with-docker","title":"With Docker","text":"<p>faucet is also available as a Docker image, for detailed usage instructions with Docker, refer to faucet in Containers.</p>"},{"location":"examples/","title":"Examples with faucet","text":""},{"location":"examples/#faucet-with-plumber-apis-inside-r-packages","title":"faucet with Plumber APIs inside R packages","text":"<p>If you have a Plumber API embedded inside an R Package, you will need to use an <code>entrypoint.R</code> file to tell Plumber how to run the API.</p> <p>Example Project</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#faucet-is-not-load-balancing-my-shiny-app-on-google-cloud-run","title":"faucet is not load balancing my Shiny App on Google Cloud Run.","text":"<p>Google Cloud Run has a proxy between the requests sent and the actual underlying services. Therefore we need to tell faucet who is connecting and how to read the end-user's IP address.</p> <p>We can fix this by setting the <code>FAUCET_IP_FROM</code> environment variable or <code>--ip-from</code> CLI argument to <code>x-forwarded-for</code>.</p>"},{"location":"faq/#im-getting-address-already-in-use-errors-with-my-workers","title":"I'm getting \"address already in use\" errors with my workers.","text":"<p>If you see errors like <code>createTcpServer: address already in use</code> or <code>Failed to create server</code>, this typically means that your application code has hardcoded port settings that conflict with faucet's port management.</p> <p>Faucet automatically assigns unique ports to each worker, but your application code might be overriding these with explicit port declarations.</p> <p>Common causes and solutions:</p> <ul> <li>Shiny apps: Check for <code>options(shiny.port = ...)</code> calls in your code and remove them. Also avoid hardcoded ports in <code>shiny::runApp(port = ...)</code> calls.</li> <li>Plumber APIs: Remove explicit port settings in <code>plumber::pr_run(port = ...)</code> calls.</li> <li>Other services: Ensure no hardcoded ports are set in configuration files or startup scripts.</li> </ul> <p>Let faucet manage the port assignments automatically for proper load balancing to work.</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#quick-start","title":"Quick Start","text":"<p>To use faucet, ensure that it is installed. If not, refer to the official installation documentation.</p> <p>Once installed, use the following command to start faucet with default settings:</p> <pre><code># Start faucet\nfaucet start\n</code></pre> <p>faucet will bind to <code>127.0.0.1:3838</code> and automatically determine the number of worker threads based on the number of CPUs on the host machine.</p>"},{"location":"getting_started/#running-a-shiny-application","title":"Running a Shiny Application","text":"<p>Let's create a simple Shiny application and deploy it using faucet.</p> <ol> <li>Create a basic Shiny app named <code>app.R</code>:</li> </ol> <pre><code># app.R\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  shinyOutput(\"hello\")\n)\n\nserver &lt;- function(input, output) {\n  output$hello &lt;- renderText({\n    \"Hello, faucet!\"\n  })\n}\n\nshinyApp(ui, server)\n</code></pre> <ol> <li> <p>Save the above code in a file named <code>app.R</code>.</p> </li> <li> <p>Start faucet in the same directory as your Shiny app:</p> </li> </ol> <pre><code>faucet start\n</code></pre> <p>faucet will automatically detect the Shiny app and deploy it.</p> <ol> <li>Open your web browser and navigate to http://127.0.0.1:3838 to see your Shiny app in action.</li> </ol>"},{"location":"getting_started/#running-a-quarto-application","title":"Running a Quarto Application","text":"<p>To run a Quarto application using faucet, follow these steps:</p> <ol> <li> <p>Ensure you have a Quarto document file, e.g., <code>example.qmd</code>.</p> </li> <li> <p>In the same directory as your Quarto document, start faucet with the Quarto settings:</p> </li> </ol> <pre><code>faucet start --qmd example.qmd --type quarto-shiny\n</code></pre> <p>All other arguments still persist and can be customized as needed.</p> <p>faucet will deploy the Quarto document as a Shiny application.</p> <ol> <li>Open your web browser and navigate to http://127.0.0.1:3838 to see your Quarto app in action.</li> </ol>"},{"location":"getting_started/#running-a-fastapi-application","title":"Running a FastAPI Application","text":"<p>faucet can also serve Python applications built with FastAPI. This feature relies on <code>uv</code> being available in your system's <code>PATH</code>.</p> <ol> <li> <p>Create a simple FastAPI application. Create a file named <code>main.py</code> in your project directory:</p> <p>```python</p> </li> <li> <p>You will need <code>uvicorn</code> and <code>fastapi</code> in your Python environment. If you are using <code>uv</code>, you can install them with:</p> <p><code>bash uv pip install fastapi uvicorn</code></p> </li> <li> <p>Start faucet and point it to your FastAPI application:</p> <p><code>bash faucet start --type fast-api --dir .</code> faucet will look for a <code>main.py</code> file in the specified directory, and then serve it using <code>uv run uvicorn main:app</code>.</p> </li> <li> <p>Open your web browser and navigate to http://127.0.0.1:3838 to see your FastAPI app's response.</p> </li> </ol>"},{"location":"getting_started/#mainpy","title":"main.py","text":"<p>from fastapi import FastAPI</p> <p>app = FastAPI()</p> <p>@app.get(\"/\") def read_root():     return {\"Hello\": \"Faucet\"} ```</p>"},{"location":"getting_started/#running-an-r-script","title":"Running an R Script","text":"<p>You can run arbitrary R scripts using the <code>rscript</code> subcommand. Faucet will manage the execution of the script.</p> <ol> <li> <p>Create an R script, for example <code>task.R</code>:</p> <p>```R</p> </li> <li> <p>Execute the script using faucet:</p> <p><code>bash faucet rscript task.R</code> This will run <code>Rscript task.R</code> under faucet's management. You can pass any arguments to your script as you normally would.</p> </li> </ol>"},{"location":"getting_started/#taskr","title":"task.R","text":"<p>print(\"Executing a task in R.\") Sys.sleep(5) print(\"Task finished.\") ```</p>"},{"location":"getting_started/#running-a-python-script","title":"Running a Python Script","text":"<p>Similarly, you can run Python scripts or any <code>uv</code> command using the <code>uv</code> subcommand. This requires <code>uv</code> to be installed and available in your <code>PATH</code>.</p> <ol> <li> <p>Create a Python script, for example <code>task.py</code>:</p> <p>```python</p> </li> <li> <p>Execute the script using faucet:</p> <p><code>bash faucet uv run task.py</code> This will execute <code>uv run task.py</code>. Any arguments can be passed to <code>uv</code>. For example, to install a package into the current environment:</p> <p><code>bash faucet uv pip install requests</code></p> </li> </ol>"},{"location":"getting_started/#taskpy","title":"task.py","text":"<p>import time print(\"Executing a task in Python.\") time.sleep(5) print(\"Task finished.\") ```</p>"},{"location":"getting_started/#adding-more-workers","title":"Adding more workers","text":"<p>If your computer has more than one CPU core, then you probably saw that many workers were created when you started faucet. This is because faucet automatically detects the number of CPU cores on your computer and creates a worker for each core.</p> <p>To know how many CPU cores you have, you can run:</p> <pre><code>faucet start -- help\n</code></pre> <p>In the output, look for the flag -w, --workers . The default number is set to the number of CPU cores detected by Faucet. <p>You can customize the number of workers by using the <code>--workers</code> flag:</p> <pre><code>faucet start --workers 4\n</code></pre> <p>Or by setting the <code>FAUCET_WORKERS</code> environment variable:</p> <pre><code>export FAUCET_WORKERS=4\nfaucet start\n</code></pre> <p>In both cases, faucet will create 4 workers on random available ports. Traffic will be load balanced across all workers according to the IP address of the incoming request. This means that if you have 4 workers, then you can handle 4 times as many concurrent requests as a single worker.</p>"},{"location":"getting_started/#router-mode","title":"Router Mode","text":"<p>When to use Router?</p> <ul> <li> <p>Multiple Applications: Use Router mode when you need to deploy and manage multiple applications on different routes but on the same port.</p> </li> <li> <p>Centralized Management: If you desire a centralized configuration to route requests to the corresponding applications based on the route, Router is the appropriate option.</p> </li> <li> <p>Resource Optimization: Router facilitates the management and scalability of various applications by allowing an efficient distribution of requests.</p> </li> </ul> <p>To start faucet in Router mode, we first need a configuration file where the router logic <code>frouter.toml</code> will be placed. The configuration file must be in the root of the working directory where you want to run the applications.</p> <p>Note: Remember that faucet router automatically detects the app.R (Shiny) file, so if there are many Shiny applications, we must specify the folder where that app.R file is located.</p> <p>To better explain the configuration, we have an example repository called faucet-router-example. This repository has different applications (Quarto, Shiny, and Plumber) in separate folders.</p> <pre><code>\u2502   .gitignore\n\u2502   faucet-router-example.Rproj\n\u2502   frouter.toml\n\u2502   README.md\n\u2502\n\u2502\n\u2502   app.R\n\u2502\n\u251c\u2500\u2500\u2500sliders\n\u2502       app.R\n\u2502\n\u2514\u2500\u2500\u2500text\n\u2502        app.R\n\u251c\u2500\u2500\u2500api\n\u2502       plumber.R\n\u2502\n\u251c\u2500\u2500\u2500qmd\n\u2502   \u2502   old_faithful.qmd\n\u2502\n\u251c\u2500\u2500\u2500py-api\n\u2502   \u2502   main.py\n</code></pre> <p>Example <code>frouter.toml</code>:</p> <pre><code># By default, the `workdir` and `app_dir`\n# is `.` (Here). If not specified,\n# runs the application in the current directory.\n[[route]]\nroute = \"/\"\nworkers = 1\nserver_type = \"Shiny\"\n\n\n# In this route, we use `workdir` to start the secondary\n# R session in a different working directory.\n[[route]]\nroute = \"/sliders/\"\nworkers = 1\nserver_type = \"Shiny\"\nworkdir = \"./sliders\"\n\n\n# In this route, we use `app_dir` to start the R session\n# in the current working directory but use an application in\n# a directory.\n[[route]]\nroute = \"/text/\"\nworkers = 1\nserver_type = \"Shiny\"\napp_dir = \"./text\"\n\n\n# Demonstration of how to serve a Plumber API\n[[route]]\nroute = \"/api/\"\nworkers = 1\nserver_type = \"Plumber\"\nworkdir = \"./api\"\n\n\n# Demonstration of how to serve a Quarto Shiny application\n[[route]]\nroute = \"/qmd/\"\nworkers = 1\nserver_type = \"QuartoShiny\"\nworkdir = \"./qmd\"\nqmd = \"old_faithful.qmd\"\n\n# Demonstration of how to serve a FastAPI application\n[[route]]\nroute = \"/py-api/\"\nworkers = 1\nserver_type = \"FastAPI\"\nworkdir = \"./py-api\"\n</code></pre> <p>The <code>server_type</code> argument defines the type of application you want to deploy; currently, we have: <code>QuartoShiny</code>, <code>Shiny</code>, <code>Plumber</code>, and <code>FastAPI</code>.</p> <p>In the same configuration file <code>frouter.toml</code>, we can define the number of <code>workers</code> that each application needs.</p> <p>Now, to start faucet in Router mode:</p> <pre><code>faucet router\n</code></pre>"},{"location":"getting_started/#routes","title":"Routes:","text":"<p>All the applications will be on the same port but with different routes, according to the configuration file.</p> <ul> <li>Hello Shiny [<code>/</code>]: <code>http://localhost:3838</code></li> <li>Sliders Shiny [<code>/sliders/</code>]: <code>http://localhost:3838/sliders/</code></li> <li>Text Shiny [<code>/text/</code>]: <code>http://localhost:3838/text/</code></li> <li>Plumber API [<code>/api/</code>]: <code>http://localhost:3838/api/__docs__/</code></li> <li>Quarto Shiny App [<code>/qmd/</code>]: <code>http://localhost:3838/qmd/</code></li> <li>FastAPI App [<code>/py-api/</code>]: <code>http://localhost:3838/py-api/</code></li> </ul>"},{"location":"getting_started/#conclusion","title":"Conclusion","text":"<p>Congratulations! You have successfully started using faucet and deployed a basic Shiny application with many workers.</p> <p>Happy coding with faucet!</p>"},{"location":"in_containers/","title":"faucet in Containers (Docker)","text":"<p>Probably the easiest and most versatile way to deploy faucet is to build a Linux container image and run it in a container. This will allow you to run faucet on any Linux host that supports containers, like a laptop, a VM, or a server.</p>"},{"location":"in_containers/#build-a-docker-image-for-faucet","title":"Build a Docker Image for faucet","text":"<p>In this section, you will be using the available faucet + R image from the Docker Hub. You can however, build your own image if you want to. You should use the available installation instructions for your OS to install Docker.</p> <p>In order to properly build the faucet image, you will need to take the following steps into account:</p> <ol> <li>Install Docker on your host machine. You can find instructions    on how to do this for your specific OS in the    Docker Installation Guide.</li> <li>Take your R application dependencies into account. If you are    using R packages that require system dependencies, you will    need to install them in the Docker image. Also, take the R    and library versions into account, we highly recommend you    use renv.    For this tutorial we will assume you are using <code>renv</code> already.</li> <li>Ignore sensitive or unnecessary files. You can use a <code>.dockerignore</code>    file to ignore files that are not needed in the Docker image or    you can manually specify the files you want to include in the    image. In this case, we will use a <code>.dockerignore</code> file to ignore    said files.</li> </ol>"},{"location":"in_containers/#a-basic-shiny-app-or-plumber-api","title":"A basic Shiny app or Plumber API","text":"<p>In this section, you will bootstrap a basic Shiny app or Plumber API to use as an example. You can use your own app or API, but make sure you have <code>renv</code> initialized.</p>"},{"location":"in_containers/#shiny-app","title":"Shiny app","text":"<pre><code># app.R\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  titlePanel(\"Hello Shiny!\"),\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\"obs\", \"Number of observations:\", min = 10, max = 500, value = 100)\n    ),\n    mainPanel(\n      plotOutput(\"distPlot\")\n    )\n  )\n)\n\nserver &lt;- function(input, output) {\n  output$distPlot &lt;- renderPlot({\n    hist(rnorm(input$obs))\n  })\n}\n\nshinyApp(ui = ui, server = server)\n</code></pre> <p>After saving the app, you can run it locally with:</p> <pre><code>shiny::runApp()\n</code></pre> <p>To make absolutely sure that <code>renv</code> detects all the packages used in the app, you should create a <code>dependencies.R</code> file with the following contents:</p> <pre><code># dependencies.R\nlibrary(shiny)\n</code></pre> <p>Now, you can initialize <code>renv</code> and install the packages:</p> <pre><code>renv::init()\nrenv::activate()\n</code></pre>"},{"location":"in_containers/#plumber-api","title":"Plumber API","text":"<pre><code># plumber.R\n#* @get /echo\nfunction(){\n  list(msg = \"Hello World!\")\n}\n</code></pre> <p>After saving the API, you can run it locally with:</p> <pre><code>library(plumber)\n# 'plumber.R' is the location of the file shown above\npr(\"plumber.R\") %&gt;%\n  pr_run()\n</code></pre> <p>To make absolutely sure that <code>renv</code> detects all the packages used in the API, you should create a <code>dependencies.R</code> file with the following contents:</p> <pre><code># dependencies.R\nlibrary(plumber)\n</code></pre> <p>Now, you can initialize <code>renv</code> and install the packages:</p> <pre><code>renv::init()\nrenv::activate()\n</code></pre>"},{"location":"in_containers/#dockerfile","title":"Dockerfile","text":""},{"location":"in_containers/#dockerignore","title":"Dockerignore","text":"<p>The first step to building our Docker image is to create a <code>.dockerignore</code> file in the root of our project. This file will contain the files that you want to ignore when building the Docker image. In this case, we will ignore the following <code>renv</code> files:</p> <pre><code>renv/library/\nrenv/local/\nrenv/cellar/\nrenv/lock/\nrenv/python/\nrenv/sandbox/\nrenv/staging/\n</code></pre> <p>If this were a real project, you would probably also ignore files like <code>.git</code>, <code>.Rproj.user</code>, <code>.DS_Store</code>, and sensitive files like <code>.env</code>, <code>.htpasswd</code>, etc.</p>"},{"location":"in_containers/#writing-the-dockerfile","title":"Writing the Dockerfile","text":"<p>The first step to building our Docker image is to create a <code>Dockerfile</code> in the root of our project. This file will contain the instructions to build our Docker image. In this case, you will use the <code>ixpantia/faucet</code> image as our base image. This image is based on the <code>rocker/r-ver</code> image, which is a minimal R image based on Debian Linux.</p> <pre><code>FROM ixpantia/faucet:r4.3\n\n# Some environment variables to tell `renv`\n# to install packages in the correct location\n# and without unnecessary symlinks\nENV RENV_CONFIG_CACHE_SYMLINKS FALSE\nENV RENV_PATHS_LIBRARY /srv/faucet/renv/library\n\n# You copy the necessary files to bootstrap `renv`\nCOPY ./renv.lock .\nCOPY ./renv ./renv\nCOPY ./.Rprofile .\n\n# You install the packages\nRUN Rscript -e \"renv::restore()\"\n\n# Copy the app/API files in this case replace\n# `app.R` with `plumber.R` if you are using a\n# Plumber API\nCOPY ./app.R .\n\n# You can run the container as a non-root user\n# for security reasons if we want to though\n# this is not necessary. You could ignore this\nRUN chown -R faucet:faucet /srv/faucet/\nUSER faucet\n</code></pre>"},{"location":"in_containers/#building-the-docker-image","title":"Building the Docker image","text":"<p>Now that you have a <code>Dockerfile</code> and a <code>.dockerignore</code> file, you can build the Docker image with the following command:</p> <pre><code>docker build -t my_faucet_app .\n</code></pre>"},{"location":"in_containers/#running-the-docker-image","title":"Running the Docker image","text":"<p>Once the image is built, you can run it with the following command:</p> <pre><code>docker run --rm -p 3838:3838 my_faucet_app\n</code></pre> <p>You can now access your app/API at <code>http://localhost:3838</code>.</p>"},{"location":"in_containers/#controlling-the-faucet-instance","title":"Controlling the faucet instance","text":"<p>You can control every aspect of the faucet instance by setting environment variables in the Docker container. For example, if you want to change the number of workers, you can do so by setting the <code>FAUCET_WORKERS</code> environment variable:</p> <pre><code>docker run --rm -p 3838:3838 -e FAUCET_WORKERS=4 my_faucet_app\n</code></pre> <p>If you are running the app/API behind a proxy like Nginx, you can set the <code>FAUCET_IP_FROM</code> environment variable to <code>x-real-ip</code> or <code>x-forwarded-for</code> to make sure faucet gets the correct IP address of the client.</p> <pre><code>docker run --rm -p 3838:3838 -e FAUCET_IP_FROM=x-real-ip my_faucet_app\n</code></pre>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#option-1-binary-download-linux","title":"Option 1: Binary Download (Linux)","text":"<p>Download the latest release of faucet for Linux from the GitHub Releases page.</p> <pre><code>FAUCET_VERSION=\"v2.1.0\"\n\nwget https://github.com/ixpantia/faucet/releases/download/$FAUCET_VERSION/faucet-x86_64-unknown-linux-musl -O faucet\n\n# Make the binary executable\nchmod +x faucet\n\n# Move the binary to a directory in your PATH (e.g., user local bin)\nmv faucet ~/.local/bin\n</code></pre> <p>Note: While the binary download is expected to work on most Linux distributions, compatibility is not guaranteed for all systems. If you encounter issues, consider using the Cargo installation or building from source options.</p>"},{"location":"install/#option-2-install-with-cargo-linux-macos-windows","title":"Option 2: Install with Cargo (Linux, macOS, Windows)","text":"<p>Install faucet with Cargo, Rust's package manager.</p> <ol> <li>Install Rust by following the instructions here.</li> </ol> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> <ol> <li>Install faucet with Cargo.</li> </ol> <pre><code>cargo install faucet-server\n</code></pre>"},{"location":"install/#option-3-build-from-source-linux-macos-windows","title":"Option 3: Build from Source (Linux, macOS, Windows)","text":"<ol> <li>Install Rust by following the instructions here.</li> </ol> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> <ol> <li>Clone the faucet repository.</li> </ol> <pre><code>git clone https://github.com/ixpantia/faucet.git\n</code></pre> <ol> <li>Build faucet with Cargo.</li> </ol> <pre><code>cargo install --path .\n</code></pre>"},{"location":"load_balancing/","title":"Load Balancing Strategies in Faucet","text":"<p>Load balancing is a critical component for distributing network traffic across multiple Faucet worker processes, each typically running an instance of an R application (like Shiny, Plumber, or Quarto Shiny). This distribution ensures that no single worker becomes overwhelmed, leading to improved responsiveness, availability, and reliability of your deployed applications. This document outlines the load balancing strategies available in Faucet, their use cases, and their respective advantages and disadvantages.</p> <p>Faucet allows you to configure the load balancing strategy using the <code>--strategy</code> command-line option or the <code>FAUCET_STRATEGY</code> environment variable. The available strategies are:</p> <ul> <li>Round Robin</li> <li>IP Hash</li> <li>Cookie Hash</li> </ul>"},{"location":"load_balancing/#default-strategies","title":"Default Strategies","text":"<p>Faucet applies default strategies based on the application type if not explicitly specified: *   Shiny and Quarto Shiny applications: Default to <code>ip-hash</code> to ensure session persistence. *   Plumber APIs: Default to <code>round-robin</code> as they are often stateless.</p>"},{"location":"load_balancing/#common-features-worker-health-and-retries","title":"Common Features: Worker Health and Retries","text":"<p>All load balancing strategies in Faucet incorporate a mechanism to handle offline worker processes. If a selected backend worker is detected as offline:</p> <ol> <li>Faucet will log the attempt to connect to the offline worker.</li> <li>An exponential backoff retry mechanism is employed.</li> <li>Behavior upon worker failure differs by strategy:<ul> <li>Round Robin: After a short wait (<code>WAIT_TIME_UNTIL_RETRY</code>), Faucet will attempt to route the request to the next available worker in the sequence.</li> <li>IP Hash &amp; Cookie Hash: Faucet will continue to retry connecting to the originally designated worker. This means requests for that specific worker are effectively \"held\" and will experience latency or appear to hang until the worker is back online or the request times out. Clients are not automatically rerouted to a different worker because that would break session persistence.</li> </ul> </li> </ol>"},{"location":"load_balancing/#1-round-robin","title":"1. Round Robin","text":""},{"location":"load_balancing/#description","title":"Description","text":"<p>The Round Robin strategy distributes incoming requests to Faucet's worker processes in a sequential order. Each new request is sent to the next worker in the list. When the end of the list is reached, the load balancer returns to the beginning and starts over.</p>"},{"location":"load_balancing/#use-cases","title":"Use Cases","text":"<ul> <li>Stateless Applications: Ideal for stateless applications like many Plumber APIs, where each request can be handled independently by any worker.</li> <li>Simple Deployments: Suitable when all worker processes are expected to have similar processing capabilities.</li> </ul>"},{"location":"load_balancing/#pros","title":"Pros","text":"<ul> <li>Simplicity: Easy to understand and implement.</li> <li>Even Distribution (ideal conditions): If all workers are healthy and have similar capacities, Round Robin can distribute traffic relatively evenly.</li> <li>Low Overhead: Minimal computational cost for the load balancer.</li> <li>Resilience to Worker Failure: If a worker goes offline, requests are automatically routed to the next available worker after a brief delay.</li> </ul>"},{"location":"load_balancing/#cons","title":"Cons","text":"<ul> <li>Ignores Worker Load: Does not take into account the current load on individual worker processes (beyond basic online/offline checks).</li> <li>No Session Persistence: Clients might be directed to different workers on subsequent requests. This makes it unsuitable for stateful applications like Shiny or Quarto Shiny apps that require session stickiness (e.g., maintaining user-specific data or input states).</li> <li>Uneven Distribution with Varying Capacities: If worker processes have different underlying capacities (though Faucet typically spawns identical R processes), some might become overloaded.</li> </ul>"},{"location":"load_balancing/#2-ip-hash","title":"2. IP Hash","text":""},{"location":"load_balancing/#description_1","title":"Description","text":"<p>The IP Hash strategy uses the client's IP address to determine which Faucet worker process will handle the request. A hash function is applied to the client's IP address, and the resulting hash value consistently maps to a specific worker.</p> <p>Important for Reverse Proxy Setups: If Faucet is running behind a reverse proxy (e.g., Nginx, Apache), it's crucial to configure the <code>--ip-from</code> option (or <code>FAUCET_IP_FROM</code> environment variable) correctly. This tells Faucet whether to use the direct client IP or an IP from a header like <code>X-Forwarded-For</code> or <code>X-Real-IP</code>, ensuring accurate IP identification for this strategy.</p>"},{"location":"load_balancing/#use-cases_1","title":"Use Cases","text":"<ul> <li>Stateful Applications (Default for Shiny/Quarto): Essential for applications like Shiny and Quarto Shiny apps that require session persistence. It ensures that a client is consistently routed to the same worker process, maintaining their session state.</li> <li>Caching Benefits: Can improve cache hit rates on the worker if data is cached based on user interactions.</li> </ul>"},{"location":"load_balancing/#pros_1","title":"Pros","text":"<ul> <li>Session Persistence: Guarantees that requests from the same client IP are consistently routed to the same worker, crucial for stateful R applications.</li> <li>Deterministic Routing: The same IP will always route to the same worker (assuming the pool of workers hasn't changed).</li> </ul>"},{"location":"load_balancing/#cons_1","title":"Cons","text":"<ul> <li>Uneven Load Distribution:<ul> <li>If a few IP addresses generate a disproportionately large volume of traffic, the workers assigned to those IPs can become overloaded.</li> <li>Clients behind a Network Address Translation (NAT) gateway or a large corporate proxy will all appear to have the same source IP. All these clients will be directed to the same worker, potentially overwhelming it.</li> </ul> </li> <li>Changing Client IPs: Session persistence can be lost if a client's IP address changes during their session (e.g., mobile users switching between Wi-Fi and cellular data).</li> <li>Worker Failures: If a designated worker goes down, requests for clients hashing to that worker will be held and retried against the same worker, leading to delays for those users until the worker is restored. They are not automatically rerouted to preserve session integrity.</li> </ul>"},{"location":"load_balancing/#3-cookie-hash","title":"3. Cookie Hash","text":""},{"location":"load_balancing/#description_2","title":"Description","text":"<p>The Cookie Hash strategy achieves session persistence by using an HTTP cookie named <code>FAUCET_LB_COOKIE</code>. When a request arrives: 1.  Faucet checks for the <code>FAUCET_LB_COOKIE</code>. 2.  If the cookie exists and contains a valid UUID, Faucet uses this UUID to consistently select a backend worker process. 3.  If the cookie is not present, is invalid, or the strategy is <code>CookieHash</code> and no suitable cookie UUID is found, Faucet generates a new UUID. 4.  This UUID (either extracted or newly generated) is then used to determine the worker. 5.  Crucially, Faucet will set (or update) the <code>FAUCET_LB_COOKIE</code> in the HTTP response, including the UUID. This ensures that subsequent requests from the same client browser will include this cookie, directing them to the same worker.</p> <p>This mechanism ensures the client is consistently directed to the same worker for subsequent requests as long as their browser accepts and sends cookies.</p>"},{"location":"load_balancing/#use-cases_2","title":"Use Cases","text":"<ul> <li>Robust Stateful Applications: Provides reliable session persistence for Shiny, Quarto Shiny, or other stateful applications. It's particularly beneficial when client IP addresses are not stable or when many clients might share an IP address (e.g., users behind large NATs or proxies).</li> <li>Fine-grained Session Control: Offers more precise control over session stickiness than IP Hash, as it relies on a unique identifier (the cookie's UUID) specific to the client's session, managed by Faucet.</li> </ul>"},{"location":"load_balancing/#pros_2","title":"Pros","text":"<ul> <li>Reliable Session Persistence: More robust than IP Hash in scenarios with dynamic client IPs or NAT, as it depends on the Faucet-managed cookie.</li> <li>Better Load Distribution (than IP Hash in NAT scenarios): Can distribute load more evenly than IP Hash when many users share the same source IP, as each user's browser session will get its own <code>FAUCET_LB_COOKIE</code> with a unique UUID.</li> <li>Deterministic Routing: The same cookie UUID will consistently route to the same worker (assuming the worker pool is stable).</li> <li>Automatic Cookie Management by Faucet: Faucet handles the generation and setting of the necessary cookie, simplifying setup.</li> </ul>"},{"location":"load_balancing/#cons_2","title":"Cons","text":"<ul> <li>Client Cookie Support: Relies on clients accepting and sending cookies. If a client has cookies disabled, this strategy will not provide session persistence.</li> <li>Cookie Overhead: Involves the standard overhead of HTTP cookie transmission and processing, though Faucet's management is efficient.</li> <li>Worker Failures: Similar to IP Hash, if a worker designated by a cookie hash goes down, requests associated with that cookie hash will be held and retried against the same worker, potentially causing delays for affected users.</li> <li>Initial Simultaneous Requests: As noted in the Faucet source code, if a browser sends multiple simultaneous initial requests before the first <code>Set-Cookie</code> response is processed and returned by the browser, those initial requests might briefly hit different workers before settling on the one determined by the eventually set cookie. This is a minor edge case for most applications.</li> </ul> <p>Choosing the right load balancing strategy in Faucet depends heavily on the specific requirements of your R application, particularly its statefulness, and your deployment environment (e.g., standalone vs. behind a reverse proxy). For Shiny and Quarto Shiny apps, <code>ip-hash</code> (default) or <code>cookie-hash</code> are generally recommended. For stateless Plumber APIs, <code>round-robin</code> (default) is often sufficient.</p>"},{"location":"logging/","title":"Logging","text":"<p>faucet takes care of logging both HTTP requests and responses, as well as the <code>stdout</code> and <code>stderr</code> of the worker processes. This section describes how logging works in faucet and how to filter the logs.</p>"},{"location":"logging/#basic-structure","title":"Basic structure","text":"<p>All logs generated by faucet take the following form:</p> <pre><code>[&lt;time stamp&gt; level &lt;source&gt;] &lt;message&gt;\n</code></pre> <ul> <li>The time stamp is the format <code>YYYY-MM-DDTHH:MM:SSZ</code> and is in UTC.</li> <li>The level is one of:<ul> <li><code>ERROR</code></li> <li><code>WARN</code></li> <li><code>INFO</code></li> <li><code>DEBUG</code></li> <li><code>TRACE</code></li> </ul> </li> <li>The source is either <code>faucet</code> or the name of the worker <code>Worker::&lt;id&gt;</code>.</li> </ul>"},{"location":"logging/#http-logging","title":"HTTP logging","text":"<p>HTTP logs are all logged at the <code>INFO</code> level. The source is the worker in charge of handling the request. The message has the following form:</p> <pre><code>&lt;ip&gt; \"&lt;method&gt; &lt;path&gt; &lt;protocol&gt;\" &lt;status&gt; \"&lt;user-agent&gt;\" &lt;duration&gt;\n</code></pre> <ul> <li><code>ip</code> is the IP address of the client (determined by the <code>--ip-from</code> option).</li> <li><code>method</code> is the HTTP method used.</li> <li><code>path</code> is the path of the request.</li> <li><code>protocol</code> is the HTTP protocol version used.</li> <li><code>status</code> is the HTTP status code returned.</li> <li><code>user-agent</code> is the user agent of the client.</li> <li><code>duration</code> is the time it took to handle the request in milliseconds.</li> </ul>"},{"location":"logging/#worker-logging","title":"Worker logging","text":"<p>Worker logs are divided into two components: <code>stdout</code> and <code>stderr</code>. <code>stdout</code> is logged at the <code>INFO</code> level and <code>stderr</code> is logged at the <code>WARN</code> level. The source is the worker who owns the underlying process. The message is the line of output from the process.</p>"},{"location":"logging/#event-tracing","title":"Event Tracing","text":"<p>Beyond basic logging, faucet allows you to emit structured \"events\" from your R Shiny applications. These events provide rich, machine-readable data about what's happening within your application, making it easier to monitor, debug, and analyze its behavior.</p>"},{"location":"logging/#emitting-events-from-r-shiny","title":"Emitting Events from R (Shiny)","text":"<p>To send structured events from your Shiny application, use the <code>faucet</code> R package. It provides a set of logging functions that wrap the core event emission logic:</p> <ul> <li><code>faucet::info()</code>: For general informational events.</li> <li><code>faucet::warn()</code>: For non-critical issues or warnings.</li> <li><code>faucet::error()</code>: For significant errors that require attention.</li> <li><code>faucet::debug()</code>: For detailed debugging information (typically enabled during development).</li> <li><code>faucet::trace()</code>: For very fine-grained operational details (most verbose).</li> </ul> <p>Each of these functions allows you to specify a <code>message</code>, an optional <code>body</code> for additional data, and a <code>parent</code> event to link related actions.</p> <p>1. Logging a simple informational message</p> <p>Use the <code>message</code> argument for a human-readable description of the event. You can also use <code>glue</code> syntax for dynamic messages.</p> <p>```/dev/null/example.R#L1-1 faucet::info(\"Application started successfully.\")</p> <pre><code>\nThis would generate a structured log entry containing:\n-   A unique `event_id` for this specific log.\n-   `level: \"Info\"` indicating it's an informational message.\n-   `message: \"Application started successfully.\"`\n\n**2. Including additional data with `body`**\n\nThe `body` argument accepts any R object that can be converted to JSON, such as a list. This is useful for attaching contextual data, diagnostics, or payload details to your events.\n\n```/dev/null/example.R#L1-1\nfaucet::info(\"User {user_id} logged in\", user_id = \"abc-123\", body = list(session_duration_minutes = 15, ip_address = \"192.168.1.10\"))\n</code></pre> <p>This event will capture: -   The dynamic message: <code>\"User abc-123 logged in\"</code>. -   A <code>body</code> containing a list with <code>session_duration_minutes</code> and <code>ip_address</code>, allowing you to store specific metrics or details alongside the log message.</p> <p>3. Tracing a sequence of operations with <code>parent</code></p> <p>You can link related events by passing the <code>event_id</code> of a previous event as the <code>parent</code> argument. This creates a \"parent-child\" relationship, helping you trace the flow of complex operations through your application.</p> <p>```/dev/null/example.R#L1-2 event_id_start &lt;- faucet::debug(\"Starting data retrieval from API.\")</p>"},{"location":"logging/#perform-data-retrieval","title":"... perform data retrieval ...","text":"<p>faucet::info(\"Data retrieval complete.\", parent = event_id_start, body = list(records_fetched = 1200)) ```</p> <p>In this example: -   The <code>debug</code> event marks the start of an operation, generating its own <code>event_id</code>. -   The subsequent <code>info</code> event related to completion will include the <code>event_id_start</code> as its <code>parent_event_id</code>, clearly indicating that it's a follow-up to the data retrieval initiation.</p>"},{"location":"logging/#storing-and-analyzing-event-data","title":"Storing and Analyzing Event Data","text":"<p>All structured events emitted by your Shiny applications are automatically captured by faucet and stored in the <code>faucet_log_events</code> table within your PostgreSQL database. This enables you to:</p> <ul> <li>Query and Filter: Easily search for specific events based on <code>level</code>, <code>message</code> content, or data within the <code>body</code>.</li> <li>Analyze Trends: Track the frequency of certain events or errors over time.</li> <li>Reconstruct User Journeys: Use <code>event_id</code> and <code>parent_event_id</code> to trace a user's interactions or the execution flow of a specific request through your application.</li> <li>Build Dashboards: Use the structured data to create monitoring dashboards that provide real-time insights into your application's health and performance.</li> </ul>"},{"location":"logging/#filtering-logs","title":"Filtering logs","text":"<p>By default, faucet logs at the <code>INFO</code> level, which means that <code>ERROR</code>, <code>WARN</code>, and <code>INFO</code> logs are shown. To change the log level, use the <code>FAUCET_LOG</code> environment variable.</p> <p>Note: Plumber prints errors that occur on endpoints to <code>stdout</code>, so if you want to see those errors, you will need to set the log level to <code>INFO</code> or lower. Shiny on the other hand prints errors to <code>stderr</code>, so you will need to set the log level to <code>WARN</code> or lower to see those errors.</p>"},{"location":"logging/#writing-logs-a-file","title":"Writing logs a file","text":"<p>faucet allows you to redirect log output to a file. This will disable colors on <code>stderr</code>.</p> <p>You can redirect to a file by specifying the path on the <code>FAUCET_LOG_FILE</code> environment variable or by passing the <code>--log-file</code> argument to <code>faucet start</code> or <code>faucet router</code>.</p>"},{"location":"options/","title":"Options / Config","text":"<p>This section covers all user-configurable options for faucet.</p>"},{"location":"options/#global-options","title":"Global Options","text":"<p>These options can be used with both the <code>start</code> and <code>router</code> subcommands.</p>"},{"location":"options/#host","title":"Host","text":"<ul> <li>CLI: <code>--host</code></li> <li>Environment: <code>FAUCET_HOST</code></li> <li>Default: <code>127.0.0.1:3838</code></li> </ul> <p>The host and port to bind the faucet server to. If running in a container, this should be set to <code>0.0.0.0:3838</code> to allow external access.</p>"},{"location":"options/#ip-from-how-to-determine-the-client-ip","title":"IP From (How to determine the client IP)","text":"<ul> <li>CLI: <code>--ip-from</code> or <code>-i</code></li> <li>Environment: <code>FAUCET_IP_FROM</code></li> <li>Default: <code>client</code></li> <li>Possible values:</li> <li><code>client</code></li> <li><code>x-forwarded-for</code></li> <li><code>x-real-ip</code></li> </ul> <p>How to determine the client IP. This is used to determine the IP for the IP Hash strategy and for logging of HTTP requests. If you are running faucet directly to end users, you should use <code>client</code>. If you are running faucet behind a reverse proxy like nginx, you should use <code>x-forwarded-for</code> or <code>x-real-ip</code>.</p> <p>Note: If you are running faucet behind a reverse proxy, be sure to set the <code>X-Forwarded-For</code> or <code>X-Real-IP</code> header correctly in your reverse proxy\\'s configuration.</p>"},{"location":"options/#rscript-define-a-custom-rscript-binaryexecutable","title":"Rscript (Define a custom <code>Rscript</code> binary/executable)","text":"<ul> <li>CLI: <code>--rscript</code> or <code>-r</code></li> <li>Environment: <code>FAUCET_RSCRIPT</code></li> <li>Default: <code>Rscript</code></li> </ul> <p>The <code>Rscript</code> binary/executable to use. This is useful if you need to have multiple versions of R installed on your system. This should be the full path to the <code>Rscript</code> binary/executable or an alias that is available in your <code>$PATH</code>. This is also useful in platforms like Windows where the <code>Rscript</code> binary/executable may not be available in the <code>$PATH</code>.</p>"},{"location":"options/#quarto-define-a-custom-quarto-binaryexecutable","title":"Quarto (Define a custom <code>quarto</code> binary/executable)","text":"<ul> <li>CLI: <code>--quarto</code> or <code>-q</code></li> <li>Environment: <code>FAUCET_QUARTO</code></li> <li>Default: <code>quarto</code></li> </ul> <p>The <code>quarto</code> binary/executable to use. This is useful if you have multiple versions of Quarto installed or if it\\'s not in your <code>$PATH</code>.</p>"},{"location":"options/#uv-define-a-custom-uv-binaryexecutable","title":"Uv (Define a custom <code>uv</code> binary/executable)","text":"<ul> <li>CLI: <code>--uv</code></li> <li>Environment: <code>FAUCET_UV</code></li> <li>Default: <code>uv</code></li> </ul> <p>The <code>uv</code> binary/executable to use. This is useful if you have multiple versions of <code>uv</code> installed, or if it is not in your system's <code>PATH</code>. <code>uv</code> is required for running FastAPI applications and <code>uv</code> subcommands.</p>"},{"location":"options/#log-file-redirect-logging-to-a-file","title":"Log File (Redirect logging to a file)","text":"<ul> <li>CLI: <code>--log-file</code> or <code>-l</code></li> <li>Environment: <code>FAUCET_LOG_FILE</code></li> <li>Default: <code>None</code></li> </ul> <p>If you set this variable it will disable colors on <code>stderr</code> and save all output to the specified path. This will append, not overwrite previously existing files.</p>"},{"location":"options/#max-log-file-size","title":"Max Log File Size","text":"<ul> <li>CLI: <code>--max-log-file-size</code> or <code>-m</code></li> <li>Environment: <code>FAUCET_MAX_LOG_FILE_SIZE</code></li> <li>Default: <code>None</code></li> </ul> <p>The maximum size of the log file before rotation (e.g., 10M, 1GB). Requires <code>log-file</code> to be set.</p>"},{"location":"options/#logging-level","title":"Logging Level","text":"<ul> <li>Environment: <code>FAUCET_LOG</code></li> <li>Default: <code>INFO</code></li> <li>Possible values:</li> <li><code>ERROR</code></li> <li><code>WARN</code></li> <li><code>INFO</code></li> <li><code>DEBUG</code></li> <li><code>TRACE</code></li> </ul> <p>The logging level to use. This environment variable sets the global logging verbosity. Refer to the logging section for more information. Note: While this environment variable is functional, newer applications might prefer more granular control via dedicated logger configuration files or library-specific settings if available. The CLI options <code>--log-file</code> and <code>--max-log-file-size</code> provide direct control over file-based logging.</p>"},{"location":"options/#shutdown","title":"Shutdown","text":"<ul> <li>CLI: <code>--shutdown</code></li> <li>Environment: <code>FAUCET_SHUTDOWN</code></li> <li>Default: <code>immediate</code></li> <li>Possible values:</li> <li><code>immediate</code></li> <li><code>graceful</code></li> </ul> <p>The strategy used for shutting down faucet. <code>immediate</code> kills every active connection and shutdown the process. <code>graceful</code> waits for all connections to close before shutting down.</p>"},{"location":"options/#max-message-size","title":"Max Message Size","text":"<ul> <li>CLI: <code>--max-message-size</code></li> <li>Environment: <code>FAUCEC_MAX_MESSAGE_SIZE</code></li> <li>Default: <code>None</code></li> </ul> <p>Maximum size of a WebSocket message. This is useful for DDOS prevention. If not set, there is no size limit.</p>"},{"location":"options/#telemetry-postgresql-connection-string","title":"Telemetry: PostgreSQL Connection String","text":"<ul> <li>CLI: <code>--pg-con-string</code></li> <li>Environment: <code>FAUCET_TELEMETRY_POSTGRES_STRING</code></li> <li>Default: <code>None</code></li> </ul> <p>Connection string to a PostgreSQL database for saving HTTP events. If provided, faucet will attempt to log HTTP events to this database.</p>"},{"location":"options/#telemetry-namespace","title":"Telemetry: Namespace","text":"<ul> <li>CLI: <code>--telemetry-namespace</code></li> <li>Environment: <code>FAUCET_TELEMETRY_NAMESPACE</code></li> <li>Default: <code>faucet</code></li> </ul> <p>Namespace under which HTTP events are saved in PostgreSQL.</p>"},{"location":"options/#telemetry-version","title":"Telemetry: Version","text":"<ul> <li>CLI: <code>--telemetry-version</code></li> <li>Environment: <code>FAUCET_TELEMETRY_VERSION</code></li> <li>Default: <code>None</code></li> </ul> <p>Represents the source code version of the service being run. This is useful for filtering telemetry data.</p>"},{"location":"options/#telemetry-postgresql-ssl-certificate","title":"Telemetry: PostgreSQL SSL Certificate","text":"<ul> <li>CLI: <code>--pg-sslcert</code></li> <li>Environment: <code>FAUCET_TELEMETRY_POSTGRES_SSLCERT</code></li> <li>Default: <code>None</code></li> </ul> <p>Path to a CA certificate file for verifying the PostgreSQL server when using SSL/TLS. Required if <code>--pg-sslmode</code> is set to <code>verify-ca</code> or <code>verify-full</code>. The certificate should be in PEM or DER format.</p>"},{"location":"options/#telemetry-postgresql-ssl-mode","title":"Telemetry: PostgreSQL SSL Mode","text":"<ul> <li>CLI: <code>--pg-sslmode</code></li> <li>Environment: <code>FAUCET_TELEMETRY_POSTGRES_SSLMODE</code></li> <li>Default: <code>prefer</code></li> <li>Possible values:</li> <li><code>disable</code></li> <li><code>prefer</code></li> <li><code>require</code></li> <li><code>verify-ca</code></li> <li><code>verify-full</code></li> </ul> <p>Controls the SSL/TLS behavior for the PostgreSQL connection. If set to <code>verify-ca</code> or <code>verify-full</code>, a CA certificate must be provided via <code>--pg-sslcert</code> or <code>FAUCET_TELEMETRY_POSTGRES_SSLCERT</code>.</p>"},{"location":"options/#start-subcommand-options","title":"<code>start</code> Subcommand Options","text":"<p>These options are specific to the <code>start</code> subcommand, used for running a standard faucet server.</p>"},{"location":"options/#workers","title":"Workers","text":"<ul> <li>CLI: <code>--workers</code> or <code>-w</code></li> <li>Environment: <code>FAUCET_WORKERS</code></li> <li>Default: The number of CPUs available to the process</li> </ul> <p>The number of worker processes to spawn. On a CPU-bound workload, this should be set to the number of CPUs available to the process. On an IO-bound workload, this could be set to a higher number.</p>"},{"location":"options/#strategy","title":"Strategy","text":"<ul> <li>CLI: <code>--strategy</code> or <code>-s</code></li> <li>Environment: <code>FAUCET_STRATEGY</code></li> <li>Default: <code>round-robin</code></li> <li>Possible values:</li> <li><code>round-robin</code></li> <li><code>ip-hash</code></li> <li><code>cookie-hash</code></li> </ul> <p>The strategy to use for load balancing. Which strategy you choose depends on your workload.</p>"},{"location":"options/#round-robin","title":"Round Robin","text":"<p>Round robin is a very lightweight and simple load balancing strategy. It simply distributes requests to workers in a round robin fashion. This can be a good strategy for most workloads, it is very simple and has very little overhead.</p> <p>You should NOT use round robin if the server is stateful, as it will not guarantee that requests from the same client will be routed to the same worker. If you need persistent state, use IP Hash or Cookie Hash.</p> <p>If a worker dies, the requests that were routed will continue to be the next available worker that is alive.</p>"},{"location":"options/#ip-hash","title":"IP Hash","text":"<p>IP Hash is a more complex strategy that guarantees that requests from the same client will be routed to the same worker. This is useful for stateful servers, such as Shiny apps. IP Hash is enforced on Shiny apps if the strategy is set to <code>auto</code>.</p> <p>If a worker dies, the requests will be held until the worker is back online. This means that latency may increase if a worker dies.</p>"},{"location":"options/#cookie-hash","title":"Cookie Hash","text":"<p>Cookie Hash uses a cookie to identify the worker to send the request to. This is useful for sticky sessions from within the same network, even if clients are behind a NAT or share the same IP address.</p>"},{"location":"options/#type-type-of-server","title":"Type (Type of server)","text":"<ul> <li>CLI: <code>--type</code> or <code>-t</code></li> <li>Environment: <code>FAUCET_TYPE</code></li> <li>Default: <code>auto</code></li> <li>Possible values:</li> <li><code>auto</code></li> <li><code>plumber</code></li> <li><code>shiny</code></li> <li><code>quarto-shiny</code></li> <li><code>fast-api</code></li> </ul> <p>The type of server to run. This is used to determine the correct strategy to use and how to spawn the workers.</p>"},{"location":"options/#auto","title":"Auto","text":"<p>Auto will attempt to determine the type of server based on the contents of the directory specified by <code>--dir</code>.</p> <ul> <li>If the directory contains a <code>plumber.R</code> or <code>entrypoint.R</code> file, it will be assumed to be a Plumber server.</li> <li>If the directory contains an <code>app.R</code>, or both <code>server.R</code> and <code>ui.R</code> files, it will be assumed to be a Shiny server.</li> <li>If a <code>.qmd</code> file is provided via the <code>--qmd</code> argument, or if <code>FAUCET_QMD</code> is set, it will be assumed to be a Quarto Shiny application.   Otherwise, faucet will exit with an error.</li> </ul>"},{"location":"options/#plumber","title":"Plumber","text":"<p>Runs the server as a Plumber API. The default strategy is <code>round-robin</code>.</p>"},{"location":"options/#shiny","title":"Shiny","text":"<p>Runs the server as a Shiny app. The default strategy is <code>ip-hash</code>.</p>"},{"location":"options/#quarto-shiny","title":"Quarto Shiny","text":"<p>Runs the server as a Quarto Shiny app. The default strategy is <code>ip-hash</code>. Requires the <code>--qmd</code> option to specify the Quarto document.</p>"},{"location":"options/#fastapi","title":"FastAPI","text":"<p>Runs the server as a FastAPI application. The default strategy is <code>round-robin</code>. This requires <code>uv</code> to be installed. Faucet will look for a <code>main.py</code> file in the specified directory and serve it.</p>"},{"location":"options/#directory-working-directory","title":"Directory (Working directory)","text":"<ul> <li>CLI: <code>--dir</code> or <code>-d</code></li> <li>Environment: <code>FAUCET_DIR</code></li> <li>Default: <code>.</code></li> </ul> <p>The directory to run the server from. This should be the directory that contains the <code>plumber.R</code> or Shiny app contents.</p>"},{"location":"options/#app-directory-shiny-appdir","title":"App Directory (Shiny <code>appDir</code>)","text":"<ul> <li>CLI: <code>--app-dir</code> or <code>-a</code></li> <li>Environment: <code>FAUCET_APP_DIR</code></li> <li>Default: <code>None</code></li> </ul> <p>Argument passed on to <code>appDir</code> when running Shiny applications. This allows you to specify a subdirectory within the <code>--dir</code> path as the root for the Shiny app.</p>"},{"location":"options/#qmd-quarto-document","title":"QMD (Quarto Document)","text":"<ul> <li>CLI: <code>--qmd</code></li> <li>Environment: <code>FAUCET_QMD</code></li> <li>Default: <code>None</code></li> </ul> <p>Path to the Quarto Shiny <code>.qmd</code> file. This is required when <code>type</code> is set to <code>quarto-shiny</code>, or when <code>type</code> is <code>auto</code> and you intend to run a Quarto Shiny app.</p>"},{"location":"options/#router-subcommand-options","title":"<code>router</code> Subcommand Options","text":"<p>These options are specific to the <code>router</code> subcommand, used for running faucet in router mode (experimental).</p>"},{"location":"options/#config-file","title":"Config File","text":"<ul> <li>CLI: <code>--conf</code> or <code>-c</code></li> <li>Environment: <code>FAUCET_ROUTER_CONF</code></li> <li>Default: <code>./frouter.toml</code></li> </ul> <p>Path to the router configuration TOML file.</p>"},{"location":"options/#rscript-subcommand","title":"<code>rscript</code> Subcommand","text":"<p>This subcommand allows you to execute an arbitrary R script. Any arguments following <code>rscript</code> will be passed directly to the <code>Rscript</code> executable.</p> <p>Example: <code>faucet rscript my_script.R --arg1 value1</code></p>"},{"location":"options/#uv-subcommand","title":"<code>uv</code> Subcommand","text":"<p>This subcommand allows you to execute arbitrary <code>uv</code> commands. This is particularly useful for running Python scripts or managing Python environments. Any arguments following <code>uv</code> will be passed directly to the <code>uv</code> executable.</p> <p>Example: <code>faucet uv run my_script.py</code> or <code>faucet uv pip install pandas</code></p>"},{"location":"reverse_proxy/","title":"With Reverse Proxy","text":"<p>You may want to use faucet with a reverse proxy like Nginx or Apache. This might be useful if you want to add routing, SSL, or other useful features of a reverse proxy. This page will show you some of the necessary configuration to get faucet working with a reverse proxy.</p>"},{"location":"reverse_proxy/#nginx","title":"Nginx","text":"<p>For your nginx configuration, you might want to add the following to your <code>location</code> block:</p> <pre><code>proxy_set_header Upgrade $http_upgrade;\nproxy_set_header Connection $connection_upgrade;\nproxy_set_header  X-Real-IP $remote_addr;\nproxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;\nproxy_http_version 1.1;\n</code></pre> <p>In this case we are adding the <code>Upgrade</code> and <code>Connection</code> headers so that the websocket connection will work. We are also adding the <code>X-Real-IP</code> and <code>X-Forwarded-For</code> headers so that the IP address of the client will be forwarded to faucet.</p> <p>faucet will need to be configured to trust the proxy and use either the <code>X-Real-IP</code> or <code>X-Forwarded-For</code> header to get the IP address of the client. This can be done by adding the <code>--ip-from</code> / <code>-i</code> command line options or by setting the <code>FAUCET_IP_FROM</code> environment variable.</p> <p>To use the <code>X-Real-IP</code> header, set the <code>FAUCET_IP_FROM</code> environment variable to <code>x-real-ip</code>. To use the <code>X-Forwarded-For</code> header, set the <code>FAUCET_IP_FROM</code> environment variable to <code>x-forwarded-for</code>.</p>"},{"location":"reverse_proxy/#apache","title":"Apache","text":"<p>For your apache configuration, you might want to add the following to your <code>VirtualHost</code> block:</p> <pre><code>RewriteEngine on\nRewriteCond %{HTTP:Upgrade} =websocket\nRewriteRule /(.*) ws://localhost:3838/$1 [P,L]\nRewriteCond %{HTTP:Upgrade} !=websocket\nRewriteRule /(.*) http://localhost:3838/$1 [P,L]\n</code></pre> <p>Apache automatically adds the <code>X-Fowarded-For</code> header, so you don't need to do anything else to get the client IP address to faucet. You will need to set the <code>FAUCET_IP_FROM</code> environment variable to <code>x-forwarded-for</code> so that faucet will use the <code>X-Forwarded-For</code> header to get the IP address of the client. You can also use the <code>--ip-from</code> / <code>-i</code> command line option to set the <code>FAUCET_IP_FROM</code> environment variable.</p> <p>Similar to the Nginx setup, when Apache proxies WebSocket requests (as shown in the <code>RewriteRule</code> with the <code>ws://</code> scheme), Faucet will actively manage this connection. It receives the upgrade request, performs the necessary WebSocket handshake with your backend R application, and then proxies the WebSocket data.</p>"},{"location":"router/","title":"Faucet Router Mode","text":"<p>Faucet's router mode allows you to serve multiple distinct applications from a single Faucet instance. Each application, or \"route,\" can have its own configuration (like application type, working directory, number of workers, and load balancing strategy) and is accessible via a unique URL path prefix.</p> <p>This is particularly useful for:</p> <ul> <li>Hosting multiple Shiny apps, Plumber APIs, or Quarto Shiny documents on the same server and port.</li> <li>Deploying different versions or configurations of the same application under different paths.</li> <li>Consolidating your R application deployments into a single Faucet process.</li> </ul>"},{"location":"router/#video-overview","title":"Video Overview","text":"<p>For a visual demonstration of the Faucet router feature, check out the following video:</p>"},{"location":"router/#activating-router-mode","title":"Activating Router Mode","text":"<p>To run Faucet in router mode, you use the <code>router</code> subcommand:</p> <pre><code>faucet router [OPTIONS]\n</code></pre> <p>The primary option for router mode is to specify the configuration file:</p> <ul> <li>CLI: <code>--conf &lt;PATH_TO_CONFIG_FILE&gt;</code> or <code>-c &lt;PATH_TO_CONFIG_FILE&gt;</code></li> <li>Environment Variable: <code>FAUCET_ROUTER_CONF=&lt;PATH_TO_CONFIG_FILE&gt;</code></li> <li>Default: If not specified, Faucet will look for a file named <code>frouter.toml</code> in the current working directory (<code>./frouter.toml</code>).</li> </ul> <p>Global Faucet options such as <code>--host</code>, <code>--ip-from</code>, <code>--rscript</code>, <code>--quarto</code>, and telemetry settings (e.g., <code>--pg-con-string</code>) apply to the entire router instance and all routes it manages.</p>"},{"location":"router/#configuration-file-froutertoml","title":"Configuration File (<code>frouter.toml</code>)","text":"<p>The router mode is configured using a TOML file. This file must define an array named <code>route</code>, where each element in the array is an object configuring a specific application route.</p> <p>Here's the structure of a single route object within the <code>frouter.toml</code> file:</p> <pre><code>[[route]]\n# The URL path prefix for this application.\n# This prefix MUST end with a trailing slash (e.g., \"/app/\", \"/api/v1/\").\n# If it's the root path, it should be \"/\".\n# (Required)\nroute = \"/my_application/\"\n\n# The type of application.\n# (Required)\n# Possible values: \"plumber\", \"shiny\", \"quarto-shiny\"\n# Aliases like \"Plumber\", \"Shiny\", \"QuartoShiny\" are also accepted.\nserver_type = \"shiny\"\n\n# The working directory for this specific application.\n# Files like app.R or plumber.R will be looked for relative to this directory,\n# or within the `app_dir` if specified. Paths can be relative (to where frouter.toml is) or absolute.\n# (Optional, defaults to \".\" - the directory where frouter.toml is located)\nworkdir = \"./apps/my_shiny_app\"\n\n# The subdirectory within `workdir` where the application's main file (e.g., app.R) is located.\n# If your app.R is directly in `workdir`, you can omit this or set it to \".\".\n# (Optional)\napp_dir = \"source\" # Looks for ./apps/my_shiny_app/source/app.R\n\n# The number of worker processes to spawn for this application.\n# (Required)\nworkers = 2\n\n# The load balancing strategy for this application.\n# (Optional, defaults depend on application type: \"ip-hash\" for shiny/quarto-shiny, \"round-robin\" for plumber)\n# Possible values: \"round-robin\", \"ip-hash\", \"cookie-hash\"\nstrategy = \"ip-hash\"\n\n# Path to the Quarto document (.qmd file), required if server_type is \"quarto-shiny\".\n# The path should be relative to `workdir` or an absolute path.\n# (Optional, but required for quarto-shiny)\n# qmd = \"dashboard.qmd\"\n</code></pre>"},{"location":"router/#fields-explained","title":"Fields Explained:","text":"<ul> <li><code>route</code> (String, Required): The URL path prefix. This prefix must end with a trailing slash (e.g., <code>/app/</code>, <code>/api/v1/</code>) unless it is the root route (<code>/</code>). Faucet will direct requests starting with this path to the configured application.</li> <li><code>server_type</code> (String, Required): Determines the type of R application. Must be one of <code>plumber</code>, <code>shiny</code>, or <code>quarto-shiny</code>. Aliases like <code>Plumber</code>, <code>Shiny</code>, <code>QuartoShiny</code> are also accepted.</li> <li><code>workdir</code> (String, Optional): The base working directory for the application. If not specified, it defaults to the directory where Faucet is running (typically where <code>frouter.toml</code> is located). Paths for <code>app_dir</code> and <code>qmd</code> are typically resolved relative to this.</li> <li><code>app_dir</code> (String, Optional): A subdirectory within <code>workdir</code> that contains the application's main file (e.g., <code>app.R</code> for Shiny, <code>plumber.R</code> for Plumber). For example, if <code>workdir = \"./my_app_collection\"</code> and <code>app_dir = \"specific_app_src\"</code>, Faucet will look for <code>./my_app_collection/specific_app_src/app.R</code>. If the main file is directly in <code>workdir</code>, you can omit this or use <code>app_dir = \".\"</code>.</li> <li><code>workers</code> (Integer, Required): The number of R worker processes to launch for this specific route. Must be a positive integer.</li> <li><code>strategy</code> (String, Optional): The load balancing strategy for this route.<ul> <li>For <code>shiny</code> and <code>quarto-shiny</code> apps, <code>ip-hash</code> is generally recommended and is the default to ensure session persistence.</li> <li>For <code>plumber</code> APIs, <code>round-robin</code> is the default.</li> <li>Available options: <code>round-robin</code>, <code>ip-hash</code>, <code>cookie-hash</code>.</li> </ul> </li> <li><code>qmd</code> (String, Optional): If <code>server_type</code> is <code>quarto-shiny</code>, this field is required and must specify the path to the <code>.qmd</code> file. This path is typically relative to <code>workdir</code>.</li> </ul> <p>Important: Each <code>route</code> value in the configuration file must be unique. Duplicate routes will cause Faucet to exit with an error on startup.</p>"},{"location":"router/#routing-behavior-and-path-stripping","title":"Routing Behavior and Path Stripping","text":"<p>When Faucet receives an HTTP request in router mode:</p> <ol> <li>It iterates through the <code>[[route]]</code> definitions in <code>frouter.toml</code> in the order they are defined.</li> <li>Route Matching and Order:<ul> <li>For each defined route, Faucet checks if the incoming request's URL path starts with the route's <code>route</code> prefix.</li> <li>The first route that matches is used. This means the order of your routes in <code>frouter.toml</code> is critical. More specific routes (e.g., <code>/app/feature1/</code>) must be listed before more general routes (e.g., <code>/app/</code>) if they share a common base path, to prevent the general route from \"shadowing\" the specific one. The root route <code>/</code> should generally be listed last.</li> </ul> </li> <li>Path Stripping:<ul> <li>All <code>route</code> prefixes (except for the root route <code>/</code>) must end with a trailing slash (<code>/</code>).</li> <li>Once a matching route is found, its defined <code>route</code> prefix is stripped from the beginning of the request's URL path.</li> <li>The remaining part of the path is then forwarded to the application configured for that route.</li> <li>Example: If <code>route = \"/myapp/\"</code> is defined:<ul> <li>A request to <code>/myapp/users/1</code> results in the application seeing <code>/users/1</code>.</li> <li>A request to <code>/myapp/</code> (with the trailing slash) results in the application seeing <code>/</code>.</li> </ul> </li> <li>Example: If <code>route = \"/\"</code> is defined:<ul> <li>A request to <code>/page</code> results in the application seeing <code>/page</code>.</li> <li>A request to <code>/</code> results in the application seeing <code>/</code>.</li> </ul> </li> </ul> </li> <li>If a matching route is found, the request (with the potentially modified path) is handed over to the Faucet server instance managing that specific application, which then applies its configured load balancing strategy to select a worker.</li> <li>If no configured <code>route</code> matches the incoming request's path, Faucet returns a <code>404 Not Found</code> response.</li> </ol>"},{"location":"router/#example-froutertoml","title":"Example <code>frouter.toml</code>","text":"<p>This example is based on the <code>faucet-router-example</code> available in the Faucet GitHub repository under the <code>examples/</code> directory. To run this example, navigate to <code>examples/faucet-router-example-main/</code> and run <code>faucet router</code>.</p> <pre><code># frouter.toml\n# This file is located in examples/faucet-router-example-main/\n\n# Route for the \"sliders\" Shiny application.\n# `workdir` is set to \"./sliders\", so Faucet looks for app.R\n# in examples/faucet-router-example-main/sliders/app.R\n[[route]]\nroute = \"/sliders/\"\nworkers = 1\nserver_type = \"shiny\" # Note: \"Shiny\" (capitalized) is also accepted\nworkdir = \"./sliders\"\n\n# Route for the \"text\" Shiny application.\n# `workdir` defaults to \".\" (where frouter.toml is).\n# `app_dir` is \"./text\", so Faucet looks for app.R\n# in examples/faucet-router-example-main/text/app.R\n[[route]]\nroute = \"/text/\"\nworkers = 1\nserver_type = \"shiny\"\napp_dir = \"./text\"\n\n# Route for a Quarto Shiny document.\n# `workdir` is \"./qmd\".\n# `qmd` specifies \"old_faithful.qmd\" relative to workdir.\n# Faucet looks for examples/faucet-router-example-main/qmd/old_faithful.qmd\n[[route]]\nroute = \"/qmd/\"\nworkers = 1\nserver_type = \"quarto-shiny\" # Note: \"QuartoShiny\" (capitalized) is also accepted\nworkdir = \"./qmd\"\nqmd = \"old_faithful.qmd\"\n\n# Route for a Plumber API.\n# `workdir` is \"./api\". Faucet looks for plumber.R\n# in examples/faucet-router-example-main/api/plumber.R\n[[route]]\nroute = \"/api/\"\nworkers = 1\nserver_type = \"plumber\" # Note: \"Plumber\" (capitalized) is also accepted\nworkdir = \"./api\"\nstrategy = \"round-robin\"\n\n# Root route for the main Shiny application.\n# `workdir` defaults to \".\" (where frouter.toml is).\n# Faucet looks for app.R in examples/faucet-router-example-main/app.R\n# This route is placed last to avoid shadowing other specific routes.\n[[route]]\nroute = \"/\"\nworkers = 1\nserver_type = \"shiny\"\nstrategy = \"cookie-hash\"\n</code></pre> <p>With the configuration above, if Faucet is running on <code>http://localhost:3838</code> from the <code>examples/faucet-router-example-main/</code> directory:</p> <ul> <li>Requests to <code>http://localhost:3838/sliders/</code> would be routed to the Shiny app in the <code>sliders</code> subdirectory.</li> <li>Requests to <code>http://localhost:3838/text/</code> would be routed to the Shiny app in the <code>text</code> subdirectory.</li> <li>Requests to <code>http://localhost:3838/qmd/</code> would be routed to the <code>old_faithful.qmd</code> Quarto Shiny document.</li> <li>Requests to <code>http://localhost:3838/api/echo?msg=hello</code> would be routed to the Plumber API in the <code>api</code> subdirectory (the API would see <code>/echo?msg=hello</code>).</li> <li>Requests to <code>http://localhost:3838/</code> would be routed to the <code>app.R</code> in the root of the <code>faucet-router-example-main</code> directory.</li> </ul> <p>Note on Route Order: Remember that if you have routes with overlapping base paths (e.g., <code>/data/specific/</code> and <code>/data/</code>), you must list the more specific route (<code>/data/specific/</code>) before the more general route (<code>/data/</code>) in your <code>frouter.toml</code> file. Otherwise, the general route <code>/data/</code> would match requests intended for <code>/data/specific/</code>, and the specific route would never be reached. The root route <code>/</code> should typically be the last entry.</p> <p>This router mode provides a flexible way to manage and serve multiple R applications efficiently using a single Faucet instance.</p>"},{"location":"telemetry/","title":"Telemetry in Faucet","text":"<p>Faucet includes a telemetry feature designed to help you monitor the performance and usage patterns of your deployed applications. When enabled, Faucet can send telemetry data to a PostgreSQL database, allowing for analysis and insights into how your Faucet instances and the underlying R applications are operating.</p> <p>This document outlines how to configure and utilize Faucet's telemetry capabilities.</p>"},{"location":"telemetry/#database-setup","title":"Database Setup","text":"<p>Before enabling telemetry, you need to set up your PostgreSQL database with the required table. Faucet will send its telemetry data to a table named <code>faucet_http_events</code>.</p> <p>You can create this table using the following SQL command:</p> <pre><code>CREATE TABLE faucet_http_events (\n    request_uuid UUID,\n    namespace TEXT,\n    version TEXT,\n    target TEXT,\n    worker_route TEXT,\n    worker_id INT,\n    ip_addr INET,\n    method TEXT,\n    path TEXT,\n    query_params TEXT,\n    http_version TEXT,\n    status SMALLINT,\n    user_agent TEXT,\n    elapsed BIGINT,\n    time TIMESTAMPTZ NOT NULL\n);\n</code></pre> <p>Note for TimescaleDB Users:</p> <p>If you are using TimescaleDB, you can optionally convert this table into a hypertable for better time-series data management. After creating the table as shown above, you can run the following SQL command:</p> <pre><code>SELECT create_hypertable('faucet_http_events', by_range('time'));\n</code></pre> <p>This step is specific to TimescaleDB and enhances its capabilities for handling large volumes of time-series data.</p>"},{"location":"telemetry/#enabling-and-configuring-telemetry","title":"Enabling and Configuring Telemetry","text":"<p>Telemetry in Faucet is disabled by default. To enable it, you must provide a PostgreSQL connection string. Configuration can be done via command-line options or environment variables.</p>"},{"location":"telemetry/#key-configuration-options","title":"Key Configuration Options:","text":"<ol> <li> <p>PostgreSQL Connection String:</p> <ul> <li>CLI: <code>--telemetry-postgres-string &lt;CONNECTION_STRING&gt;</code></li> <li>Environment Variable: <code>FAUCET_TELEMETRY_POSTGRES_STRING=&lt;CONNECTION_STRING&gt;</code></li> <li>Description: This is the essential setting to enable telemetry. The connection string should be in a format suitable for connecting to your PostgreSQL database (e.g., <code>postgresql://user:password@host:port/database</code>). Faucet will use this to send telemetry data.</li> <li>Default: <code>None</code> (Telemetry disabled)</li> </ul> </li> <li> <p>Telemetry Namespace:</p> <ul> <li>CLI: <code>--telemetry-namespace &lt;NAMESPACE&gt;</code></li> <li>Environment Variable: <code>FAUCET_TELEMETRY_NAMESPACE=&lt;NAMESPACE&gt;</code></li> <li>Description: Allows you to define a namespace for the telemetry data. This is useful if you are collecting data from multiple Faucet instances or different services into the same database, helping to segment and identify the source of the data.</li> <li>Default: <code>faucet</code></li> </ul> </li> <li> <p>Telemetry Version:</p> <ul> <li>CLI: <code>--telemetry-version &lt;VERSION&gt;</code></li> <li>Environment Variable: <code>FAUCET_TELEMETRY_VERSION=&lt;VERSION&gt;</code></li> <li>Description: Specifies the version of the service or application being run/monitored by Faucet. This can be your application's version or Faucet's version itself. It's helpful for filtering telemetry data and correlating observations with specific deployments.</li> <li>Default: <code>None</code></li> </ul> </li> </ol> <p>For more details on these options, refer to the Command-Line Options page.</p>"},{"location":"telemetry/#data-collected","title":"Data Collected","text":"<p>Faucet's telemetry system is designed to capture information relevant to the operational aspects of the server and the applications it manages. While the exact schema and data points may evolve, the general categories of data collected include:</p> <ul> <li>Request/Response Metrics: Information about incoming HTTP requests and the responses generated, such as request paths, response status codes, and latencies.</li> <li>Worker Performance: Data related to the behavior of individual worker processes, potentially including processing times and error rates.</li> <li>Load Balancing Events: Information about how requests are distributed if load balancing strategies are in use.</li> <li>Instance Information: Details such as the configured namespace and version, to help contextualize the data.</li> </ul> <p>The data is structured to be stored in a PostgreSQL database, allowing for SQL-based querying and integration with various analytics and visualization tools.</p>"},{"location":"telemetry/#utilizing-telemetry-data","title":"Utilizing Telemetry Data","text":"<p>Once telemetry is configured and Faucet is sending data to your PostgreSQL database, you can:</p> <ul> <li>Monitor Application Health: Track error rates, response times, and other key performance indicators (KPIs) to ensure your applications are running smoothly.</li> <li>Understand Usage Patterns: Analyze request volumes, popular endpoints, and user activity to gain insights into how your applications are being used.</li> <li>Troubleshoot Issues: Correlate telemetry data with logs and other monitoring tools to diagnose and resolve problems more effectively.</li> <li>Capacity Planning: Observe resource utilization and performance trends over time to make informed decisions about scaling your infrastructure.</li> <li>Performance Optimization: Identify bottlenecks or slow operations by examining request latencies and worker performance data.</li> </ul> <p>You can connect to the PostgreSQL database using standard SQL clients, business intelligence tools, or custom scripts to query and visualize the collected telemetry data according to your needs.</p>"},{"location":"es/","title":"faucet","text":"<p>Despliegue R\u00e1pido, As\u00edncrono y Concurrente de Aplicaciones R y Python</p>"},{"location":"es/#resumen","title":"Resumen","text":"<p>Bienvenido a faucet, tu soluci\u00f3n de alto rendimiento para desplegar APIs de Plumber, Aplicaciones Shiny y aplicaciones FastAPI con velocidad y eficiencia. Faucet es un servidor basado en Rust que ofrece balanceo de carga Round Robin, IP Hash y Cookie Hash, asegurando un escalado y distribuci\u00f3n fluidos de tus aplicaciones R y Python. Tambi\u00e9n permite ejecutar scripts arbitrarios de R y Python. Ya seas un cient\u00edfico de datos, desarrollador o entusiasta de DevOps, faucet simplifica el despliegue, facilitando la gesti\u00f3n de r\u00e9plicas y el balanceo de cargas de manera efectiva.</p>"},{"location":"es/#caracteristicas","title":"Caracter\u00edsticas","text":"<ul> <li>Alto Rendimiento: faucet aprovecha la velocidad de Rust para una ejecuci\u00f3n fluida y eficiente de aplicaciones R y Python.</li> <li>Soporte Pol\u00edglota: Despliega nativamente aplicaciones escritas en R (Plumber, Shiny) y Python (FastAPI), o ejecuta scripts arbitrarios de <code>Rscript</code> y Python (<code>uv</code>).</li> <li>Balanceo de Carga: Elige entre balanceo de carga Round Robin, IP Hash o Cookie Hash para una utilizaci\u00f3n \u00f3ptima de los recursos.</li> <li>R\u00e9plicas: Escala APIs de Plumber, Aplicaciones Shiny y aplicaciones FastAPI sin esfuerzo con m\u00faltiples r\u00e9plicas.</li> <li>Despliegue Simplificado: faucet agiliza el proceso de despliegue para una configuraci\u00f3n r\u00e1pida.</li> <li>As\u00edncrono y Concurrente: Utiliza procesamiento as\u00edncrono y concurrente para una mayor eficiencia de recursos y un manejo receptivo de las solicitudes.</li> <li>Trazado Estructurado de Eventos: Obt\u00e9n informaci\u00f3n detallada sobre tus aplicaciones Shiny con registros detallados y legibles por m\u00e1quina almacenados directamente en tu base de datos.</li> </ul>"},{"location":"es/#instalacion","title":"Instalaci\u00f3n","text":"<p>Para opciones de instalaci\u00f3n, consulta Instalaci\u00f3n.</p>"},{"location":"es/#uso","title":"Uso","text":"<p>Para instrucciones de uso detalladas, consulta Primeros Pasos.</p>"},{"location":"es/#con-docker","title":"Con Docker","text":"<p>faucet tambi\u00e9n est\u00e1 disponible como imagen de Docker. Para instrucciones de uso detalladas con Docker, consulta faucet en Contenedores.</p>"},{"location":"es/examples/","title":"Ejemplos con faucet","text":""},{"location":"es/examples/#faucet-con-apis-plumber-dentro-de-un-paquete-de-r","title":"faucet con APIs Plumber dentro de un paquete de R","text":"<p>Si tienes un API Plumber dentro de un paquete de R, ser\u00e1 necesario crear un archivo <code>entrypoint.R</code> para decirle a Plumber como correr el API.</p> <p>Proyecto de Ejemplo</p>"},{"location":"es/faq/","title":"Preguntas Frecuentes","text":""},{"location":"es/faq/#faucet-no-esta-balanceando-la-carga-de-mi-aplicacion-shiny-en-google-cloud-run","title":"faucet no est\u00e1 balanceando la carga de mi aplicaci\u00f3n Shiny en Google Cloud Run.","text":"<p>Google Cloud Run tiene un proxy entre las solicitudes enviadas y los servicios subyacentes reales. Por lo tanto, necesitamos decirle a faucet qui\u00e9n se est\u00e1 conectando y c\u00f3mo leer la direcci\u00f3n IP del usuario final.</p> <p>Podemos solucionarlo configurando la variable de entorno <code>FAUCET_IP_FROM</code> o el argumento CLI <code>--ip-from</code> a <code>x-forwarded-for</code>.</p>"},{"location":"es/faq/#estoy-obteniendo-errores-de-address-already-in-use-con-mis-workers","title":"Estoy obteniendo errores de \"address already in use\" con mis workers.","text":"<p>Si ves errores como <code>createTcpServer: address already in use</code> o <code>Failed to create server</code>, esto t\u00edpicamente significa que el c\u00f3digo de tu aplicaci\u00f3n tiene configuraciones de puerto codificadas que entran en conflicto con la gesti\u00f3n de puertos de faucet.</p> <p>Faucet asigna autom\u00e1ticamente puertos \u00fanicos a cada worker, pero el c\u00f3digo de tu aplicaci\u00f3n podr\u00eda estar sobrescribiendo estos con declaraciones expl\u00edcitas de puerto.</p> <p>Causas comunes y soluciones:</p> <ul> <li>Aplicaciones Shiny: Verifica llamadas a <code>options(shiny.port = ...)</code> en tu c\u00f3digo y elim\u00ednalas. Tambi\u00e9n evita puertos codificados en llamadas a <code>shiny::runApp(port = ...)</code>.</li> <li>APIs Plumber: Elimina configuraciones expl\u00edcitas de puerto en llamadas a <code>plumber::pr_run(port = ...)</code>.</li> <li>Otros servicios: Aseg\u00farate de que no haya puertos codificados en archivos de configuraci\u00f3n o scripts de inicio.</li> </ul> <p>Deja que faucet gestione las asignaciones de puerto autom\u00e1ticamente para que el balanceo de carga funcione correctamente.</p>"},{"location":"es/getting_started/","title":"Inicio R\u00e1pido","text":""},{"location":"es/getting_started/#inicio-rapido","title":"Inicio R\u00e1pido","text":"<p>Para usar faucet, aseg\u00farate de que est\u00e9 instalado. Si no es as\u00ed, consulta la documentaci\u00f3n oficial de instalaci\u00f3n.</p> <p>Una vez instalado, utiliza el siguiente comando para iniciar faucet con la configuraci\u00f3n predeterminada:</p> <pre><code># Iniciar faucet\nfaucet start\n</code></pre> <p>faucet se vincular\u00e1 a <code>127.0.0.1:3838</code> y determinar\u00e1 autom\u00e1ticamente el n\u00famero de hilos de trabajo bas\u00e1ndose en el n\u00famero de CPUs en la m\u00e1quina anfitriona.</p>"},{"location":"es/getting_started/#ejecutando-una-aplicacion-shiny","title":"Ejecutando una Aplicaci\u00f3n Shiny","text":"<p>Vamos a crear una aplicaci\u00f3n Shiny simple y a desplegarla usando faucet.</p> <ol> <li>Crea una aplicaci\u00f3n Shiny b\u00e1sica llamada <code>app.R</code>:</li> </ol> <pre><code># app.R\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  shinyOutput(\"hello\")\n)\n\nserver &lt;- function(input, output) {\n  output$hello &lt;- renderText({\n    \"\u00a1Hola, faucet!\"\n  })\n}\n\nshinyApp(ui, server)\n</code></pre> <ol> <li> <p>Guarda el c\u00f3digo anterior en un archivo llamado <code>app.R</code>.</p> </li> <li> <p>Inicia faucet en el mismo directorio que tu aplicaci\u00f3n Shiny:</p> </li> </ol> <pre><code>faucet start\n</code></pre> <p>faucet detectar\u00e1 autom\u00e1ticamente la aplicaci\u00f3n Shiny y la desplegar\u00e1.</p> <ol> <li>Abre tu navegador web y navega a http://127.0.0.1:3838 para ver tu aplicaci\u00f3n Shiny en acci\u00f3n.</li> </ol>"},{"location":"es/getting_started/#ejecutando-una-aplicacion-quarto","title":"Ejecutando una Aplicaci\u00f3n Quarto","text":"<p>Para ejecutar una aplicaci\u00f3n Quarto usando faucet, sigue estos pasos:</p> <ol> <li> <p>Aseg\u00farate de tener un archivo de documento Quarto, por ejemplo, <code>example.qmd</code>.</p> </li> <li> <p>En el mismo directorio que tu documento Quarto, inicia faucet con la configuraci\u00f3n de Quarto:</p> </li> </ol> <pre><code>faucet start --qmd example.qmd --type quarto-shiny\n</code></pre> <p>Todos los dem\u00e1s argumentos persisten y pueden ser personalizados seg\u00fan sea necesario.</p> <p>faucet desplegar\u00e1 el documento Quarto como una aplicaci\u00f3n Shiny.</p> <ol> <li>Abre tu navegador web y navega a http://127.0.0.1:3838 para ver tu aplicaci\u00f3n Quarto en acci\u00f3n.</li> </ol>"},{"location":"es/getting_started/#ejecutando-una-aplicacion-fastapi","title":"Ejecutando una Aplicaci\u00f3n FastAPI","text":"<p>faucet tambi\u00e9n puede servir aplicaciones de Python construidas con FastAPI. Esta caracter\u00edstica depende de que <code>uv</code> est\u00e9 disponible en el <code>PATH</code> de tu sistema.</p> <ol> <li> <p>Crea una aplicaci\u00f3n FastAPI simple. Crea un archivo llamado <code>main.py</code> en el directorio de tu proyecto:</p> <p>```python</p> </li> <li> <p>Necesitar\u00e1s <code>uvicorn</code> y <code>fastapi</code> en tu entorno de Python. Si est\u00e1s usando <code>uv</code>, puedes instalarlos con:</p> <p><code>bash uv pip install fastapi uvicorn</code></p> </li> <li> <p>Inicia faucet y ap\u00fantalo a tu aplicaci\u00f3n FastAPI:</p> <p><code>bash faucet start --type fast-api --dir .</code> faucet buscar\u00e1 un archivo <code>main.py</code> en el directorio especificado y luego lo servir\u00e1 usando <code>uv run uvicorn main:app</code>.</p> </li> <li> <p>Abre tu navegador web y navega a http://127.0.0.1:3838 para ver la respuesta de tu aplicaci\u00f3n FastAPI.</p> </li> </ol>"},{"location":"es/getting_started/#mainpy","title":"main.py","text":"<p>from fastapi import FastAPI</p> <p>app = FastAPI()</p> <p>@app.get(\"/\") def read_root():     return {\"Hola\": \"Faucet\"} ```</p>"},{"location":"es/getting_started/#ejecutando-un-script-de-r","title":"Ejecutando un Script de R","text":"<p>Puedes ejecutar scripts de R arbitrarios usando el subcomando <code>rscript</code>. Faucet gestionar\u00e1 la ejecuci\u00f3n del script.</p> <ol> <li> <p>Crea un script de R, por ejemplo <code>task.R</code>:</p> <p>```R</p> </li> <li> <p>Ejecuta el script usando faucet:</p> <p><code>bash faucet rscript task.R</code> Esto ejecutar\u00e1 <code>Rscript task.R</code> bajo la gesti\u00f3n de faucet. Puedes pasar cualquier argumento a tu script como lo har\u00edas normalmente.</p> </li> </ol>"},{"location":"es/getting_started/#taskr","title":"task.R","text":"<p>print(\"Ejecutando una tarea en R.\") Sys.sleep(5) print(\"Tarea finalizada.\") ```</p>"},{"location":"es/getting_started/#ejecutando-un-script-de-python","title":"Ejecutando un Script de Python","text":"<p>De manera similar, puedes ejecutar scripts de Python o cualquier comando <code>uv</code> usando el subcomando <code>uv</code>. Esto requiere que <code>uv</code> est\u00e9 instalado y disponible en tu <code>PATH</code>.</p> <ol> <li> <p>Crea un script de Python, por ejemplo <code>task.py</code>:</p> <p>```python</p> </li> <li> <p>Ejecuta el script usando faucet:</p> <p><code>bash faucet uv run task.py</code> Esto ejecutar\u00e1 <code>uv run task.py</code>. Se pueden pasar cualquier argumento a <code>uv</code>. Por ejemplo, para instalar un paquete en el entorno actual:</p> <p><code>bash faucet uv pip install requests</code></p> </li> </ol>"},{"location":"es/getting_started/#taskpy","title":"task.py","text":"<p>import time print(\"Ejecutando una tarea en Python.\") time.sleep(5) print(\"Tarea finalizada.\") ```</p>"},{"location":"es/getting_started/#anadiendo-mas-workers","title":"A\u00f1adiendo m\u00e1s workers","text":"<p>Si tu computadora tiene m\u00e1s de un n\u00facleo de CPU, probablemente viste que se crearon muchos workers cuando iniciaste faucet. Esto se debe a que faucet detecta autom\u00e1ticamente el n\u00famero de n\u00facleos de CPU en tu computadora y crea un worker por cada n\u00facleo.</p> <p>Para saber cu\u00e1ntos n\u00facleos de CPU tienes, puedes ejecutar:</p> <pre><code>faucet start -- help\n</code></pre> <p>En la salida, busca la bandera -w, --workers . El n\u00famero predeterminado se establece en el n\u00famero de n\u00facleos de CPU detectados por Faucet. <p>Puedes personalizar el n\u00famero de workers usando la bandera <code>--workers</code>:</p> <pre><code>faucet start --workers 4\n</code></pre> <p>O estableciendo la variable de entorno <code>FAUCET_WORKERS</code>:</p> <pre><code>export FAUCET_WORKERS=4\nfaucet start\n</code></pre> <p>En ambos casos, faucet crear\u00e1 4 workers en puertos aleatorios disponibles. El tr\u00e1fico ser\u00e1 balanceado a trav\u00e9s de todos los workers seg\u00fan la direcci\u00f3n IP de la solicitud entrante. Esto significa que si tienes 4 workers, puedes manejar 4 veces m\u00e1s solicitudes concurrentes que un solo worker.</p>"},{"location":"es/getting_started/#modo-router","title":"Modo Router","text":"<p>\u00bfCu\u00e1ndo usar el Router?</p> <ul> <li> <p>M\u00faltiples Aplicaciones: Usa el modo Router cuando necesites desplegar y gestionar m\u00faltiples aplicaciones en diferentes rutas pero en el mismo puerto.</p> </li> <li> <p>Gesti\u00f3n Centralizada: Si deseas una configuraci\u00f3n centralizada para enrutar las solicitudes a las aplicaciones correspondientes seg\u00fan la ruta, el Router es la opci\u00f3n apropiada.</p> </li> <li> <p>Optimizaci\u00f3n de Recursos: El Router facilita la gesti\u00f3n y escalabilidad de varias aplicaciones al permitir una distribuci\u00f3n eficiente de las solicitudes.</p> </li> </ul> <p>Para iniciar faucet en modo Router, primero necesitamos un archivo de configuraci\u00f3n donde se colocar\u00e1 la l\u00f3gica del router <code>frouter.toml</code>. El archivo de configuraci\u00f3n debe estar en la ra\u00edz del directorio de trabajo donde deseas ejecutar las aplicaciones.</p> <p>Nota: Recuerda que el router de faucet detecta autom\u00e1ticamente el archivo app.R (Shiny), por lo que si hay muchas aplicaciones Shiny, debemos especificar la carpeta donde se encuentra ese archivo app.R.</p> <p>Para explicar mejor la configuraci\u00f3n, tenemos un repositorio de ejemplo llamado faucet-router-example. Este repositorio tiene diferentes aplicaciones (Quarto, Shiny y Plumber) en carpetas separadas.</p> <pre><code>\u2502   .gitignore\n\u2502   faucet-router-example.Rproj\n\u2502   frouter.toml\n\u2502   README.md\n\u2502\n\u2502   app.R\n\u2502\n\u251c\u2500\u2500\u2500sliders\n\u2502       app.R\n\u2502\n\u2514\u2500\u2500\u2500text\n\u2502        app.R\n\u251c\u2500\u2500\u2500api\n\u2502       plumber.R\n\u2502\n\u251c\u2500\u2500\u2500qmd\n\u2502   \u2502   old_faithful.qmd\n\u2502\n\u251c\u2500\u2500\u2500py-api\n\u2502   \u2502   main.py\n</code></pre> <p>Ejemplo de <code>frouter.toml</code>:</p> <pre><code># Por defecto, `workdir` y `app_dir`\n# es `.` (Aqu\u00ed). Si no se especifica,\n# ejecuta la aplicaci\u00f3n en el directorio actual.\n[[route]]\nroute = \"/\"\nworkers = 1\nserver_type = \"Shiny\"\n\n\n# En esta ruta, usamos `workdir` para iniciar la sesi\u00f3n\n# secundaria de R en un directorio de trabajo diferente.\n[[route]]\nroute = \"/sliders/\"\nworkers = 1\nserver_type = \"Shiny\"\nworkdir = \"./sliders\"\n\n\n# En esta ruta, usamos `app_dir` para iniciar la sesi\u00f3n de R\n# en el directorio de trabajo actual pero usando una aplicaci\u00f3n en\n# un directorio.\n[[route]]\nroute = \"/text/\"\nworkers = 1\nserver_type = \"Shiny\"\napp_dir = \"./text\"\n\n\n# Demostraci\u00f3n de c\u00f3mo servir una API de Plumber\n[[route]]\nroute = \"/api/\"\nworkers = 1\nserver_type = \"Plumber\"\nworkdir = \"./api\"\n\n\n# Demostraci\u00f3n de c\u00f3mo servir una aplicaci\u00f3n Quarto Shiny\n[[route]]\nroute = \"/qmd/\"\nworkers = 1\nserver_type = \"QuartoShiny\"\nworkdir = \"./qmd\"\nqmd = \"old_faithful.qmd\"\n\n# Demostraci\u00f3n de c\u00f3mo servir una aplicaci\u00f3n FastAPI\n[[route]]\nroute = \"/py-api/\"\nworkers = 1\nserver_type = \"FastAPI\"\nworkdir = \"./py-api\"\n</code></pre> <p>El argumento <code>server_type</code> define el tipo de aplicaci\u00f3n que deseas desplegar; actualmente, tenemos: <code>QuartoShiny</code>, <code>Shiny</code>, <code>Plumber</code>, y <code>FastAPI</code>.</p> <p>En el mismo archivo de configuraci\u00f3n <code>frouter.toml</code>, podemos definir el n\u00famero de <code>workers</code> que necesita cada aplicaci\u00f3n.</p> <p>Ahora, para iniciar faucet en modo Router:</p> <pre><code>faucet router\n</code></pre>"},{"location":"es/getting_started/#rutas","title":"Rutas:","text":"<p>Todas las aplicaciones estar\u00e1n en el mismo puerto pero con diferentes rutas, seg\u00fan el archivo de configuraci\u00f3n.</p> <ul> <li>Hello Shiny [<code>/</code>]: <code>http://localhost:3838</code></li> <li>Sliders Shiny [<code>/sliders/</code>]: <code>http://localhost:3838/sliders/</code></li> <li>Text Shiny [<code>/text/</code>]: <code>http://localhost:3838/text/</code></li> <li>Plumber API [<code>/api/</code>]: <code>http://localhost:3838/api/__docs__/</code></li> <li>Quarto Shiny App [<code>/qmd/</code>]: <code>http://localhost:3838/qmd/</code></li> <li>FastAPI App [<code>/py-api/</code>]: <code>http://localhost:3838/py-api/</code></li> </ul>"},{"location":"es/getting_started/#conclusion","title":"Conclusi\u00f3n","text":"<p>\u00a1Felicidades! Has comenzado a usar faucet con \u00e9xito y has desplegado una aplicaci\u00f3n Shiny b\u00e1sica con muchos workers.</p> <p>\u00a1Feliz codificaci\u00f3n con faucet!</p>"},{"location":"es/in_containers/","title":"faucet en Contenedores (Docker)","text":"<p>Probablemente la manera m\u00e1s f\u00e1cil y vers\u00e1til de implementar faucet es construir una imagen de contenedor Linux y ejecutarla en un contenedor. Esto le permitir\u00e1 ejecutar faucet en cualquier host de Linux que admita contenedores, como una computadora port\u00e1til, una m\u00e1quina virtual o un servidor.</p>"},{"location":"es/in_containers/#construir-una-imagen-de-docker-para-faucet","title":"Construir una Imagen de Docker para faucet","text":"<p>En esta secci\u00f3n, utilizar\u00e1s la imagen disponible de faucet + R desde Docker Hub. Sin embargo, tambi\u00e9n puedes construir tu propia imagen si lo deseas. Debes seguir las instrucciones de instalaci\u00f3n disponibles para tu sistema operativo para instalar Docker.</p> <p>Para construir correctamente la imagen de faucet, debes tener en cuenta los siguientes pasos:</p> <ol> <li>Instalar Docker en tu m\u00e1quina host. Puedes encontrar las instrucciones espec\u00edficas para tu sistema operativo en la Gu\u00eda de Instalaci\u00f3n de Docker.</li> <li>Considerar las dependencias de tu aplicaci\u00f3n en R. Si est\u00e1s utilizando paquetes R que requieren dependencias del sistema, deber\u00e1s instalarlas en la imagen de Docker. Tambi\u00e9n, ten en cuenta las versiones de R y las bibliotecas; te recomendamos utilizar renv. Para este tutorial, asumiremos que ya est\u00e1s utilizando <code>renv</code>.</li> <li>Ignorar archivos sensibles o innecesarios. Puedes utilizar un archivo <code>.dockerignore</code> para ignorar archivos que no son necesarios en la imagen de Docker, o puedes especificar manualmente los archivos que deseas incluir en la imagen. En este caso, utilizaremos un archivo <code>.dockerignore</code> para ignorar dichos archivos.</li> </ol>"},{"location":"es/in_containers/#una-aplicacion-basica-shiny-o-plumber-api","title":"Una aplicaci\u00f3n b\u00e1sica Shiny o Plumber API","text":"<p>En esta secci\u00f3n, arrancar\u00e1s una aplicaci\u00f3n Shiny b\u00e1sica o Plumber API para utilizar como ejemplo. Puedes usar tu propia aplicaci\u00f3n o API, pero aseg\u00farate de tener <code>renv</code> inicializado.</p>"},{"location":"es/in_containers/#aplicacion-shiny","title":"Aplicaci\u00f3n Shiny","text":"<pre><code># app.R\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  titlePanel(\"\u00a1Hola Shiny!\"),\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\"obs\", \"N\u00famero de observaciones:\", min = 10, max = 500, value = 100)\n    ),\n    mainPanel(\n      plotOutput(\"distPlot\")\n    )\n  )\n)\n\nserver &lt;- function(input, output) {\n  output$distPlot &lt;- renderPlot({\n    hist(rnorm(input$obs))\n  })\n}\n\nshinyApp(ui = ui, server = server)\n</code></pre> <p>Despu\u00e9s de guardar la aplicaci\u00f3n, puedes ejecutarla localmente con:</p> <pre><code>shiny::runApp()\n</code></pre> <p>Para asegurarte de que <code>renv</code> detecte todos los paquetes utilizados en la aplicaci\u00f3n, debes crear un archivo <code>dependencies.R</code> con el siguiente contenido:</p> <pre><code># dependencies.R\nlibrary(shiny)\n</code></pre> <p>Ahora puedes inicializar <code>renv</code> e instalar los paquetes:</p> <pre><code>renv::init()\nrenv::activate()\n</code></pre>"},{"location":"es/in_containers/#plumber-api","title":"Plumber API","text":"<pre><code># plumber.R\n#* @get /echo\nfunction(){\n  list(msg = \"\u00a1Hola Mundo!\")\n}\n</code></pre> <p>Despu\u00e9s de guardar la API, puedes ejecutarla localmente con:</p> <pre><code>library(plumber)\n# 'plumber.R' es la ubicaci\u00f3n del archivo mostrado anteriormente\npr(\"plumber.R\") %&gt;%\n  pr_run()\n</code></pre> <p>Para asegurarte de que <code>renv</code> detecte todos los paquetes utilizados en la API, debes crear un archivo <code>dependencies.R</code> con el siguiente contenido:</p> <pre><code># dependencies.R\nlibrary(plumber)\n</code></pre> <p>Ahora puedes inicializar <code>renv</code> e instalar los paquetes:</p> <pre><code>renv::init()\nrenv::activate()\n</code></pre>"},{"location":"es/in_containers/#dockerignore","title":"Dockerignore","text":"<p>El primer paso para construir nuestra imagen de Docker es crear un archivo <code>.dockerignore</code> en la ra\u00edz de nuestro proyecto. Este archivo contendr\u00e1 los archivos que deseas ignorar al construir la imagen de Docker. En este caso, ignoraremos los siguientes archivos de <code>renv</code>:</p> <pre><code>renv/library/\nrenv/local/\nrenv/cellar/\nrenv/lock/\nrenv/python/\nrenv/sandbox/\nrenv/staging/\n</code></pre> <p>Si este fuera un proyecto real, probablemente tambi\u00e9n ignorar\u00edas archivos como <code>.git</code>, <code>.Rproj.user</code>, <code>.DS_Store</code> y archivos sensibles como <code>.env</code>, <code>.htpasswd</code>, etc.</p>"},{"location":"es/in_containers/#escribir-el-dockerfile","title":"Escribir el Dockerfile","text":"<p>El primer paso para construir nuestra imagen de Docker es crear un archivo <code>Dockerfile</code> en la ra\u00edz de nuestro proyecto. Este archivo contendr\u00e1 las instrucciones para construir nuestra imagen de Docker. En este caso, utilizar\u00e1s la imagen <code>ixpantia/faucet</code> como base. Esta imagen se basa en la imagen <code>rocker/r-ver</code>, que es una imagen R m\u00ednima basada en Debian Linux.</p> <pre><code>FROM ixpantia/faucet:r4.3\n\n# Algunas variables de entorno para indicar a `renv`\n# instalar paquetes en la ubicaci\u00f3n correcta\n# y sin enlaces simb\u00f3licos innecesarios\nENV RENV_CONFIG_CACHE_SYMLINKS FALSE\nENV RENV_PATHS_LIBRARY /srv/faucet/renv/library\n\n# Copias los archivos necesarios para arrancar `renv`\nCOPY ./renv.lock .\nCOPY ./renv ./renv\nCOPY ./.Rprofile .\n\n# Instalas los paquetes\nRUN Rscript -e \"renv::restore()\"\n\n# Copias los archivos de la aplicaci\u00f3n/API; en este caso,\n# reemplaza `app.R` con `plumber.R` si est\u00e1s utilizando\n# una Plumber API\nCOPY ./app.R .\n\n# Puedes ejecutar el contenedor como un usuario no root\n# por razones de seguridad, aunque esto no es necesario.\n# Puedes ignorar esto\nRUN chown -R faucet:faucet /srv/faucet/\nUSER faucet\n</code></pre>"},{"location":"es/in_containers/#construir-la-imagen-de-docker","title":"Construir la imagen de Docker","text":"<p>Ahora que tienes un <code>Dockerfile</code> y un archivo <code>.dockerignore</code>, puedes construir la imagen de Docker con el siguiente comando:</p> <pre><code>docker build -t my_faucet_app .\n</code></pre>"},{"location":"es/in_containers/#ejecutar-la-imagen-de-docker","title":"Ejecutar la imagen de Docker","text":"<p>Una vez construida la imagen, puedes ejecutarla con el siguiente comando:</p> <pre><code>docker run --rm -p 3838:3838 my_faucet_app\n</code></pre> <p>Ahora puedes acceder a tu aplicaci\u00f3n/API en <code>http://localhost:3838</code>.</p>"},{"location":"es/in_containers/#controlar-la-instancia-de-faucet","title":"Controlar la instancia de faucet","text":"<p>Puedes controlar todos los aspectos de la instancia de faucet configurando variables de entorno en el contenedor de Docker. Por ejemplo, si deseas cambiar el n\u00famero de trabajadores, puedes hacerlo configurando la variable de entorno <code>FAUCET_WORKERS</code>:</p> <pre><code>docker run --rm -p 3838:3838 -e FAUCET_WORKERS=4 my_faucet_app\n</code></pre> <p>Si est\u00e1s ejecutando la aplicaci\u00f3n/API detr\u00e1s de un proxy como Nginx, puedes configurar la variable de entorno <code>FAUCET_IP_FROM</code> en <code>x-real-ip</code> o <code>x-forwarded-for</code> para asegurarte de que faucet obtenga la direcci\u00f3n IP correcta del cliente.</p> <pre><code>docker run --rm -p 3838:3838 -e FAUCET_IP_FROM=x-real-ip my_faucet_app\n</code></pre>"},{"location":"es/install/","title":"Instalaci\u00f3n","text":""},{"location":"es/install/#opcion-1-descarga-del-binario-linux","title":"Opci\u00f3n 1: Descarga del Binario (Linux)","text":"<p>Descarga la \u00faltima versi\u00f3n de faucet para Linux desde la p\u00e1gina de lanzamientos en GitHub.</p> <pre><code>FAUCET_VERSION=\"v2.1.0\"\n\nwget https://github.com/ixpantia/faucet/releases/download/$FAUCET_VERSION/faucet-x86_64-unknown-linux-musl -O faucet\n\n# Haz el binario ejecutable\nchmod +x faucet\n\n# Mueve el binario a un directorio en tu PATH (por ejemplo, el binario local del usuario)\nmv faucet ~/.local/bin\n</code></pre> <p>Nota: Aunque se espera que la descarga del binario funcione en la mayor\u00eda de las distribuciones de Linux, no se garantiza la compatibilidad con todos los sistemas. Si encuentras problemas, considera usar la instalaci\u00f3n con Cargo o las opciones de compilaci\u00f3n desde el origen.</p>"},{"location":"es/install/#opcion-2-instalacion-con-cargo-linux-macos-windows","title":"Opci\u00f3n 2: Instalaci\u00f3n con Cargo (Linux, macOS, Windows)","text":"<p>Instala faucet con Cargo, el gestor de paquetes de Rust.</p> <ol> <li>Instala Rust siguiendo las instrucciones aqu\u00ed.</li> </ol> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> <ol> <li>Instala faucet con Cargo.</li> </ol> <pre><code>cargo install faucet-server\n</code></pre>"},{"location":"es/install/#opcion-3-compilar-desde-el-codigo-fuente-linux-macos-windows","title":"Opci\u00f3n 3: Compilar desde el C\u00f3digo Fuente (Linux, macOS, Windows)","text":"<ol> <li>Instala Rust siguiendo las instrucciones aqu\u00ed.</li> </ol> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n</code></pre> <ol> <li>Clona el repositorio de faucet.</li> </ol> <pre><code>git clone https://github.com/ixpantia/faucet.git\n</code></pre> <ol> <li>Compila faucet con Cargo.</li> </ol> <pre><code>cargo install --path .\n</code></pre>"},{"location":"es/load_balancing/","title":"Estrategias de Balanceo de Carga en Faucet","text":"<p>El balanceo de carga es un componente cr\u00edtico para distribuir el tr\u00e1fico de red entre m\u00faltiples procesos de trabajo (workers) de Faucet, cada uno ejecutando t\u00edpicamente una instancia de una aplicaci\u00f3n R (como Shiny, Plumber o Quarto Shiny). Esta distribuci\u00f3n asegura que ning\u00fan trabajador individual se sobrecargue, lo que conduce a una mejor capacidad de respuesta, disponibilidad y confiabilidad de sus aplicaciones desplegadas. Este documento describe las estrategias de balanceo de carga disponibles en Faucet, sus casos de uso y sus respectivas ventajas y desventajas.</p> <p>Faucet le permite configurar la estrategia de balanceo de carga utilizando la opci\u00f3n de l\u00ednea de comandos <code>--strategy</code> o la variable de entorno <code>FAUCET_STRATEGY</code>. Las estrategias disponibles son:</p> <ul> <li>Round Robin</li> <li>IP Hash</li> <li>Cookie Hash</li> </ul>"},{"location":"es/load_balancing/#estrategias-predeterminadas","title":"Estrategias Predeterminadas","text":"<p>Faucet aplica estrategias predeterminadas basadas en el tipo de aplicaci\u00f3n if no se especifica expl\u00edcitamente: *   Aplicaciones Shiny y Quarto Shiny: Predeterminan <code>ip-hash</code> para asegurar la persistencia de la sesi\u00f3n. *   APIs de Plumber: Predeterminan <code>round-robin</code> ya que a menudo son sin estado.</p>"},{"location":"es/load_balancing/#caracteristicas-comunes-salud-del-trabajador-y-reintentos","title":"Caracter\u00edsticas Comunes: Salud del Trabajador y Reintentos","text":"<p>Todas las estrategias de balanceo de carga en Faucet incorporan un mecanismo para manejar procesos de trabajo fuera de l\u00ednea. Si se detecta que un trabajador backend seleccionado est\u00e1 fuera de l\u00ednea:</p> <ol> <li>Faucet registrar\u00e1 el intento de conexi\u00f3n al trabajador fuera de l\u00ednea.</li> <li>Se emplea un mecanismo de reintento con retroceso exponencial (exponential backoff).</li> <li>El comportamiento ante el fallo de un trabajador difiere seg\u00fan la estrategia:<ul> <li>Round Robin: Despu\u00e9s de una corta espera (<code>WAIT_TIME_UNTIL_RETRY</code>), Faucet intentar\u00e1 enrutar la solicitud al siguiente trabajador disponible en la secuencia.</li> <li>IP Hash &amp; Cookie Hash: Faucet continuar\u00e1 reintentando la conexi\u00f3n con el trabajador designado originalmente. Esto significa que las solicitudes para ese trabajador espec\u00edfico quedan efectivamente \"retenidas\" y experimentar\u00e1n latencia o parecer\u00e1n colgarse hasta que el trabajador vuelva a estar en l\u00ednea o la solicitud expire. Los clientes no se redirigen autom\u00e1ticamente a un trabajador diferente porque eso romper\u00eda la persistencia de la sesi\u00f3n.</li> </ul> </li> </ol>"},{"location":"es/load_balancing/#descripcion","title":"Descripci\u00f3n","text":"<p>La estrategia Round Robin distribuye las solicitudes entrantes a los procesos de trabajo de Faucet en un orden secuencial. Cada nueva solicitud se env\u00eda al siguiente trabajador de la lista. Cuando se llega al final de la lista, el balanceador de carga vuelve al principio y comienza de nuevo.</p>"},{"location":"es/load_balancing/#casos-de-uso","title":"Casos de Uso","text":"<ul> <li>Aplicaciones sin Estado (Stateless): Ideal para aplicaciones sin estado como muchas APIs de Plumber, donde cada solicitud puede ser manejada independientemente por cualquier trabajador.</li> <li>Despliegues Simples: Adecuado cuando se espera que todos los procesos de trabajo tengan capacidades de procesamiento similares.</li> </ul>"},{"location":"es/load_balancing/#ventajas","title":"Ventajas","text":"<ul> <li>Simplicidad: F\u00e1cil de entender e implementar.</li> <li>Distribuci\u00f3n Equitativa (condiciones ideales): Si todos los trabajadores est\u00e1n saludables y tienen capacidades similares, Round Robin puede distribuir el tr\u00e1fico de manera relativamente uniforme.</li> <li>Baja Sobrecarga: Costo computacional m\u00ednimo para el balanceador de carga.</li> <li>Resiliencia ante Fallos de Trabajadores: Si un trabajador se desconecta, las solicitudes se enrutan autom\u00e1ticamente al siguiente trabajador disponible despu\u00e9s de un breve retraso.</li> </ul>"},{"location":"es/load_balancing/#desventajas","title":"Desventajas","text":"<ul> <li>Ignora la Carga del Trabajador: No tiene en cuenta la carga actual en los procesos de trabajo individuales (m\u00e1s all\u00e1 de las verificaciones b\u00e1sicas de en l\u00ednea/fuera de l\u00ednea).</li> <li>Sin Persistencia de Sesi\u00f3n: Los clientes pueden ser dirigidos a diferentes trabajadores en solicitudes posteriores. Esto lo hace inadecuado para aplicaciones con estado como Shiny o Quarto Shiny que requieren afinidad de sesi\u00f3n (por ejemplo, mantener datos espec\u00edficos del usuario o estados de entrada).</li> <li>Distribuci\u00f3n Desigual con Capacidades Variables: Si los procesos de trabajo tienen diferentes capacidades subyacentes (aunque Faucet t\u00edpicamente genera procesos R id\u00e9nticos), algunos podr\u00edan sobrecargarse.</li> </ul>"},{"location":"es/load_balancing/#descripcion_1","title":"Descripci\u00f3n","text":"<p>La estrategia IP Hash utiliza la direcci\u00f3n IP del cliente para determinar qu\u00e9 proceso de trabajo de Faucet manejar\u00e1 la solicitud. Se aplica una funci\u00f3n hash a la direcci\u00f3n IP del cliente y el valor hash resultante se asigna consistentemente a un trabajador espec\u00edfico.</p> <p>Importante para Configuraciones con Proxy Inverso: Si Faucet se ejecuta detr\u00e1s de un proxy inverso (por ejemplo, Nginx, Apache), es crucial configurar correctamente la opci\u00f3n <code>--ip-from</code> (o la variable de entorno <code>FAUCET_IP_FROM</code>). Esto indica a Faucet si debe usar la IP directa del cliente o una IP de una cabecera como <code>X-Forwarded-For</code> o <code>X-Real-IP</code>, asegurando una identificaci\u00f3n de IP precisa para esta estrategia.</p>"},{"location":"es/load_balancing/#casos-de-uso_1","title":"Casos de Uso","text":"<ul> <li>Aplicaciones con Estado (Predeterminado para Shiny/Quarto): Esencial para aplicaciones como Shiny y Quarto Shiny que requieren persistencia de sesi\u00f3n. Asegura que un cliente sea dirigido consistentemente al mismo proceso de trabajo, manteniendo el estado de su sesi\u00f3n.</li> <li>Beneficios de Cach\u00e9: Puede mejorar las tasas de aciertos de cach\u00e9 en el trabajador si los datos se almacenan en cach\u00e9 seg\u00fan las interacciones del usuario.</li> </ul>"},{"location":"es/load_balancing/#ventajas_1","title":"Ventajas","text":"<ul> <li>Persistencia de Sesi\u00f3n: Garantiza que las solicitudes de la misma IP de cliente se dirijan consistentemente al mismo trabajador, crucial para las aplicaciones R con estado.</li> <li>Enrutamiento Determinista: La misma IP siempre se enrutar\u00e1 al mismo trabajador (suponiendo que el grupo de trabajadores no haya cambiado).</li> </ul>"},{"location":"es/load_balancing/#desventajas_1","title":"Desventajas","text":"<ul> <li>Distribuci\u00f3n de Carga Desigual:<ul> <li>Si unas pocas direcciones IP generan un volumen de tr\u00e1fico desproporcionadamente grande, los trabajadores asignados a esas IP pueden sobrecargarse.</li> <li>Los clientes detr\u00e1s de una puerta de enlace de Traducci\u00f3n de Direcciones de Red (NAT) o un gran proxy corporativo parecer\u00e1n tener todos la misma IP de origen. Todos estos clientes ser\u00e1n dirigidos al mismo trabajador, lo que podr\u00eda sobrecargarlo.</li> </ul> </li> <li>Cambio de IP del Cliente: La persistencia de la sesi\u00f3n puede perderse si la direcci\u00f3n IP de un cliente cambia durante su sesi\u00f3n (por ejemplo, usuarios m\u00f3viles cambiando entre Wi-Fi y datos celulares).</li> <li>Fallos del Trabajador: Si un trabajador designado se cae, las solicitudes de los clientes cuyo hash de IP corresponde a ese trabajador ser\u00e1n retenidas y reintentadas contra el mismo trabajador, lo que provocar\u00e1 retrasos para esos usuarios hasta que el trabajador se restaure. No se redirigen autom\u00e1ticamente para preservar la integridad de la sesi\u00f3n.</li> </ul>"},{"location":"es/load_balancing/#descripcion_2","title":"Descripci\u00f3n","text":"<p>La estrategia Cookie Hash logra la persistencia de la sesi\u00f3n mediante el uso de una cookie HTTP llamada <code>FAUCET_LB_COOKIE</code>. Cuando llega una solicitud: 1.  Faucet verifica la existencia de la cookie <code>FAUCET_LB_COOKIE</code>. 2.  Si la cookie existe y contiene un UUID v\u00e1lido, Faucet utiliza este UUID para seleccionar consistentemente un proceso de trabajo backend. 3.  Si la cookie no est\u00e1 presente, no es v\u00e1lida, o si la estrategia es <code>CookieHash</code> y no se encuentra un UUID de cookie adecuado, Faucet genera un nuevo UUID. 4.  Este UUID (ya sea extra\u00eddo o reci\u00e9n generado) se utiliza para determinar el trabajador. 5.  De manera crucial, Faucet establecer\u00e1 (o actualizar\u00e1) la <code>FAUCET_LB_COOKIE</code> en la respuesta HTTP, incluyendo el UUID. Esto asegura que las solicitudes posteriores del mismo navegador cliente incluyan esta cookie, dirigi\u00e9ndolas al mismo trabajador.</p> <p>Este mecanismo asegura que el cliente sea dirigido consistentemente al mismo trabajador para solicitudes posteriores, siempre y cuando su navegador acepte y env\u00ede cookies.</p>"},{"location":"es/load_balancing/#casos-de-uso_2","title":"Casos de Uso","text":"<ul> <li>Aplicaciones Robustas con Estado: Proporciona persistencia de sesi\u00f3n confiable para Shiny, Quarto Shiny u otras aplicaciones con estado. Es particularmente beneficioso cuando las direcciones IP de los clientes no son estables o cuando muchos clientes pueden compartir una direcci\u00f3n IP (por ejemplo, usuarios detr\u00e1s de grandes NATs o proxies).</li> <li>Control Fino de Sesiones: Ofrece un control m\u00e1s preciso sobre la afinidad de sesi\u00f3n que IP Hash, ya que se basa en un identificador \u00fanico (el UUID de la cookie) espec\u00edfico de la sesi\u00f3n del cliente, gestionado por Faucet.</li> </ul>"},{"location":"es/load_balancing/#ventajas_2","title":"Ventajas","text":"<ul> <li>Persistencia de Sesi\u00f3n Confiable: M\u00e1s robusto que IP Hash en escenarios con IPs de cliente din\u00e1micas o NAT, ya que depende de la cookie gestionada por Faucet.</li> <li>Mejor Distribuci\u00f3n de Carga (que IP Hash en escenarios NAT): Puede distribuir la carga de manera m\u00e1s uniforme que IP Hash cuando muchos usuarios comparten la misma IP de origen, ya que la sesi\u00f3n del navegador de cada usuario obtendr\u00e1 su propia <code>FAUCET_LB_COOKIE</code> con un UUID \u00fanico.</li> <li>Enrutamiento Determinista: El mismo UUID de cookie se enrutar\u00e1 consistentemente al mismo trabajador (suponiendo que el grupo de trabajadores sea estable).</li> <li>Gesti\u00f3n Autom\u00e1tica de Cookies por Faucet: Faucet maneja la generaci\u00f3n y el establecimiento de la cookie necesaria, simplificando la configuraci\u00f3n.</li> </ul>"},{"location":"es/load_balancing/#desventajas_2","title":"Desventajas","text":"<ul> <li>Soporte de Cookies del Cliente: Depende de que los clientes acepten y env\u00eden cookies. Si un cliente tiene las cookies deshabilitadas, esta estrategia no proporcionar\u00e1 persistencia de sesi\u00f3n.</li> <li>Sobrecarga de Cookies: Implica la sobrecarga est\u00e1ndar de transmisi\u00f3n y procesamiento de cookies HTTP, aunque la gesti\u00f3n de Faucet es eficiente.</li> <li>Fallos del Trabajador: Similar a IP Hash, si un trabajador designado por un hash de cookie se cae, las solicitudes asociadas con ese hash de cookie ser\u00e1n retenidas y reintentadas contra el mismo trabajador, causando potencialmente retrasos a los usuarios afectados.</li> <li>Solicitudes Simult\u00e1neas Iniciales: Como se indica en el c\u00f3digo fuente de Faucet, si un navegador env\u00eda m\u00faltiples solicitudes iniciales simult\u00e1neas antes de que la primera respuesta <code>Set-Cookie</code> sea procesada y devuelta por el navegador, esas solicitudes iniciales podr\u00edan brevemente acceder a diferentes trabajadores antes de establecerse en el determinado por la cookie finalmente establecida. Este es un caso l\u00edmite menor para la mayor\u00eda de las aplicaciones.</li> </ul> <p>Elegir la estrategia de balanceo de carga correcta en Faucet depende en gran medida de los requisitos espec\u00edficos de su aplicaci\u00f3n R, particularmente su estado (statefulness), y su entorno de despliegue (por ejemplo, independiente vs. detr\u00e1s de un proxy inverso). Para aplicaciones Shiny y Quarto Shiny, generalmente se recomienda <code>ip-hash</code> (predeterminado) o <code>cookie-hash</code>. Para APIs de Plumber sin estado, <code>round-robin</code> (predeterminado) suele ser suficiente.</p>"},{"location":"es/logging/","title":"Logging","text":"<p>faucet se encarga de hacer logs tanto de las solicitudes y respuestas HTTP como de la salida est\u00e1ndar (<code>stdout</code>) y la salida de error (<code>stderr</code>) de los procesos trabajadores. Esta secci\u00f3n describe c\u00f3mo funcionan los logs en faucet y c\u00f3mo filtrar los logs.</p>"},{"location":"es/logging/#estructura-basica","title":"Estructura b\u00e1sica","text":"<p>Todos los logs generados por faucet siguen la siguiente estructura:</p> <pre><code>[&lt;marca de tiempo&gt; nivel &lt;fuente&gt;] &lt;mensaje&gt;\n</code></pre> <ul> <li>La marca de tiempo tiene el formato <code>AAAA-MM-DDTHH:MM:SSZ</code> y est\u00e1 en UTC.</li> <li>El nivel puede ser uno de los siguientes:<ul> <li><code>ERROR</code></li> <li><code>WARN</code></li> <li><code>INFO</code></li> <li><code>DEBUG</code></li> <li><code>TRACE</code></li> </ul> </li> <li>La fuente es ya sea faucet o el nombre del trabajador <code>Worker::&lt;id&gt;</code>.</li> </ul>"},{"location":"es/logging/#logging-http","title":"Logging HTTP","text":"<p>Los logs HTTP se registran todos a nivel <code>INFO</code>. La fuente es el trabajador encargado de manejar la solicitud. El mensaje tiene la siguiente forma:</p> <pre><code>&lt;ip&gt; \"&lt;m\u00e9todo&gt; &lt;ruta&gt; &lt;protocolo&gt;\" &lt;estado&gt; \"&lt;agente-de-usuario&gt;\" &lt;duraci\u00f3n&gt;\n</code></pre> <ul> <li><code>ip</code> es la direcci\u00f3n IP del cliente (determinada por la opci\u00f3n <code>--ip-from</code>).</li> <li><code>m\u00e9todo</code> es el m\u00e9todo HTTP utilizado.</li> <li><code>ruta</code> es la ruta de la solicitud.</li> <li><code>protocolo</code> es la versi\u00f3n del protocolo HTTP utilizada.</li> <li><code>estado</code> es el c\u00f3digo de estado HTTP devuelto.</li> <li><code>agente-de-usuario</code> es el agente de usuario del cliente.</li> <li><code>duraci\u00f3n</code> es el tiempo que tom\u00f3 manejar la solicitud en milisegundos.</li> </ul>"},{"location":"es/logging/#logging-de-trabajadores","title":"Logging de trabajadores","text":"<p>Los logs de trabajadores se dividen en dos componentes: <code>stdout</code> y <code>stderr</code>. <code>stdout</code> se loggea a nivel <code>INFO</code> y <code>stderr</code> se loggea a nivel <code>WARN</code>. La fuente es el trabajador que posee el proceso subyacente. El mensaje es la l\u00ednea de salida del proceso.</p>"},{"location":"es/logging/#filtrado-de-logs","title":"Filtrado de logs","text":"<p>Por defecto, faucet logea a nivel <code>INFO</code>, lo que significa que se muestran los logs de <code>ERROR</code>, <code>WARN</code> e <code>INFO</code>. Para cambiar el nivel de log, utilice la variable de entorno <code>FAUCET_LOG</code>.</p> <p>Nota: Plumber imprime errores que ocurren en puntos finales en <code>stdout</code>, por lo que si desea ver esos errores, deber\u00e1 establecer el nivel de log en <code>INFO</code> o inferior. Shiny, por otro lado, imprime errores en <code>stderr</code>, por lo que deber\u00e1 establecer el nivel de log en <code>WARN</code> o inferior para ver esos errores.</p>"},{"location":"es/options/","title":"Opciones / Configuraci\u00f3n","text":"<p>Esta secci\u00f3n cubre todas las opciones configurables por el usuario para faucet.</p>"},{"location":"es/options/#opciones-globales","title":"Opciones Globales","text":"<p>Estas opciones se pueden usar con los subcomandos <code>start</code> y <code>router</code>.</p>"},{"location":"es/options/#host","title":"Host","text":"<ul> <li>CLI: <code>--host</code></li> <li>Entorno: <code>FAUCET_HOST</code></li> <li>Predeterminado: <code>127.0.0.1:3838</code></li> </ul> <p>El host y el puerto al que se vincular\u00e1 el servidor faucet. Si se ejecuta en un contenedor, esto deber\u00eda establecerse en <code>0.0.0.0:3838</code> para permitir el acceso externo.</p>"},{"location":"es/options/#ip-from-como-determinar-la-ip-del-cliente","title":"IP From (C\u00f3mo determinar la IP del cliente)","text":"<ul> <li>CLI: <code>--ip-from</code> o <code>-i</code></li> <li>Entorno: <code>FAUCET_IP_FROM</code></li> <li>Predeterminado: <code>client</code></li> <li>Valores posibles:</li> <li><code>client</code></li> <li><code>x-forwarded-for</code></li> <li><code>x-real-ip</code></li> </ul> <p>C\u00f3mo determinar la IP del cliente. Esto se utiliza para determinar la IP para la estrategia de IP Hash y para el registro de solicitudes HTTP. Si est\u00e1s ejecutando faucet directamente para los usuarios finales, deber\u00edas usar <code>client</code>. Si est\u00e1s ejecutando faucet detr\u00e1s de un proxy inverso como nginx, deber\u00edas usar <code>x-forwarded-for</code> o <code>x-real-ip</code>.</p> <p>Nota: Si est\u00e1s ejecutando faucet detr\u00e1s de un proxy inverso, aseg\u00farate de establecer correctamente la cabecera <code>X-Forwarded-For</code> o <code>X-Real-IP</code> en la configuraci\u00f3n de tu proxy inverso.</p>"},{"location":"es/options/#rscript-definir-un-binarioejecutable-rscript-personalizado","title":"Rscript (Definir un binario/ejecutable <code>Rscript</code> personalizado)","text":"<ul> <li>CLI: <code>--rscript</code> o <code>-r</code></li> <li>Entorno: <code>FAUCET_RSCRIPT</code></li> <li>Predeterminado: <code>Rscript</code></li> </ul> <p>El binario/ejecutable <code>Rscript</code> a utilizar. Esto es \u00fatil si necesitas tener varias versiones de R instaladas en tu sistema. Debe ser la ruta completa al binario/ejecutable <code>Rscript</code> o un alias que est\u00e9 disponible en tu <code>$PATH</code>. Esto tambi\u00e9n es \u00fatil en plataformas como Windows donde el binario/ejecutable <code>Rscript</code> puede no estar disponible en el <code>$PATH</code>.</p>"},{"location":"es/options/#quarto-definir-un-binarioejecutable-quarto-personalizado","title":"Quarto (Definir un binario/ejecutable <code>quarto</code> personalizado)","text":"<ul> <li>CLI: <code>--quarto</code> o <code>-q</code></li> <li>Entorno: <code>FAUCET_QUARTO</code></li> <li>Predeterminado: <code>quarto</code></li> </ul> <p>El binario/ejecutable <code>quarto</code> a utilizar. Esto es \u00fatil si tienes varias versiones de Quarto instaladas o si no est\u00e1 en tu <code>$PATH</code>.</p>"},{"location":"es/options/#uv-definir-un-binarioejecutable-uv-personalizado","title":"Uv (Definir un binario/ejecutable <code>uv</code> personalizado)","text":"<ul> <li>CLI: <code>--uv</code></li> <li>Entorno: <code>FAUCET_UV</code></li> <li>Predeterminado: <code>uv</code></li> </ul> <p>El binario/ejecutable <code>uv</code> a utilizar. Esto es \u00fatil si tienes m\u00faltiples versiones de <code>uv</code> instaladas, o si no est\u00e1 en el <code>PATH</code> de tu sistema. <code>uv</code> es requerido para ejecutar aplicaciones FastAPI y subcomandos <code>uv</code>.</p>"},{"location":"es/options/#log-file-redirigir-el-registro-a-un-archivo","title":"Log File (Redirigir el registro a un archivo)","text":"<ul> <li>CLI: <code>--log-file</code> o <code>-l</code></li> <li>Entorno: <code>FAUCET_LOG_FILE</code></li> <li>Predeterminado: <code>None</code></li> </ul> <p>Si estableces esta variable, se desactivar\u00e1n los colores en <code>stderr</code> y se guardar\u00e1 toda la salida en la ruta especificada. Esto a\u00f1adir\u00e1 contenido, no sobrescribir\u00e1 archivos existentes.</p>"},{"location":"es/options/#max-log-file-size","title":"Max Log File Size","text":"<ul> <li>CLI: <code>--max-log-file-size</code> o <code>-m</code></li> <li>Entorno: <code>FAUCET_MAX_LOG_FILE_SIZE</code></li> <li>Predeterminado: <code>None</code></li> </ul> <p>El tama\u00f1o m\u00e1ximo del archivo de registro antes de la rotaci\u00f3n (p. ej., 10M, 1GB). Requiere que <code>log-file</code> est\u00e9 configurado.</p>"},{"location":"es/options/#logging-level","title":"Logging Level","text":"<ul> <li>Entorno: <code>FAUCET_LOG</code></li> <li>Predeterminado: <code>INFO</code></li> <li>Valores posibles:</li> <li><code>ERROR</code></li> <li><code>WARN</code></li> <li><code>INFO</code></li> <li><code>DEBUG</code></li> <li><code>TRACE</code></li> </ul> <p>El nivel de registro a utilizar. Esta variable de entorno establece la verbosidad global del registro. Consulta la secci\u00f3n de registro para m\u00e1s informaci\u00f3n. Nota: Aunque esta variable de entorno es funcional, las aplicaciones m\u00e1s nuevas podr\u00edan preferir un control m\u00e1s granular a trav\u00e9s de archivos de configuraci\u00f3n de logger dedicados o configuraciones espec\u00edficas de la biblioteca si est\u00e1n disponibles. Las opciones de CLI <code>--log-file</code> y <code>--max-log-file-size</code> proporcionan control directo sobre el registro basado en archivos.</p>"},{"location":"es/options/#shutdown","title":"Shutdown","text":"<ul> <li>CLI: <code>--shutdown</code></li> <li>Entorno: <code>FAUCET_SHUTDOWN</code></li> <li>Predeterminado: <code>immediate</code></li> <li>Valores posibles:</li> <li><code>immediate</code></li> <li><code>graceful</code></li> </ul> <p>La estrategia utilizada para apagar faucet. <code>immediate</code> termina cada conexi\u00f3n activa y apaga el proceso. <code>graceful</code> espera a que todas las conexiones se cierren antes de apagarse.</p>"},{"location":"es/options/#max-message-size","title":"Max Message Size","text":"<ul> <li>CLI: <code>--max-message-size</code></li> <li>Entorno: <code>FAUCET_MAX_MESSAGE_SIZE</code></li> <li>Predeterminado: <code>None</code></li> </ul> <p>Tama\u00f1o m\u00e1ximo de un mensaje de WebSocket. Esto es \u00fatil para la prevenci\u00f3n de ataques DDOS. Si no se establece, no hay l\u00edmite de tama\u00f1o.</p>"},{"location":"es/options/#telemetria-cadena-de-conexion-de-postgresql","title":"Telemetr\u00eda: Cadena de Conexi\u00f3n de PostgreSQL","text":"<ul> <li>CLI: <code>--pg-con-string</code></li> <li>Entorno: <code>FAUCET_TELEMETRY_POSTGRES_STRING</code></li> <li>Predeterminado: <code>None</code></li> </ul> <p>Cadena de conexi\u00f3n a una base de datos PostgreSQL para guardar eventos HTTP. Si se proporciona, faucet intentar\u00e1 registrar los eventos HTTP en esta base de datos.</p>"},{"location":"es/options/#telemetria-namespace","title":"Telemetr\u00eda: Namespace","text":"<ul> <li>CLI: <code>--telemetry-namespace</code></li> <li>Entorno: <code>FAUCET_TELEMETRY_NAMESPACE</code></li> <li>Predeterminado: <code>faucet</code></li> </ul> <p>Espacio de nombres bajo el cual se guardan los eventos HTTP en PostgreSQL.</p>"},{"location":"es/options/#telemetria-version","title":"Telemetr\u00eda: Versi\u00f3n","text":"<ul> <li>CLI: <code>--telemetry-version</code></li> <li>Entorno: <code>FAUCET_TELEMETRY_VERSION</code></li> <li>Predeterminado: <code>None</code></li> </ul> <p>Representa la versi\u00f3n del c\u00f3digo fuente del servicio que se est\u00e1 ejecutando. Esto es \u00fatil para filtrar datos de telemetr\u00eda.</p>"},{"location":"es/options/#telemetria-certificado-ssl-de-postgresql","title":"Telemetr\u00eda: Certificado SSL de PostgreSQL","text":"<ul> <li>CLI: <code>--pg-sslcert</code></li> <li>Entorno: <code>FAUCET_TELEMETRY_POSTGRES_SSLCERT</code></li> <li>Predeterminado: <code>None</code></li> </ul> <p>Ruta a un archivo de certificado de CA para verificar el servidor PostgreSQL al usar SSL/TLS. Requerido si <code>--pg-sslmode</code> se establece en <code>verify-ca</code> o <code>verify-full</code>. El certificado debe estar en formato PEM o DER.</p>"},{"location":"es/options/#telemetria-modo-ssl-de-postgresql","title":"Telemetr\u00eda: Modo SSL de PostgreSQL","text":"<ul> <li>CLI: <code>--pg-sslmode</code></li> <li>Entorno: <code>FAUCET_TELEMETRY_POSTGRES_SSLMODE</code></li> <li>Predeterminado: <code>prefer</code></li> <li>Valores posibles:</li> <li><code>disable</code></li> <li><code>prefer</code></li> <li><code>require</code></li> <li><code>verify-ca</code></li> <li><code>verify-full</code></li> </ul> <p>Controla el comportamiento de SSL/TLS para la conexi\u00f3n de PostgreSQL. Si se establece en <code>verify-ca</code> o <code>verify-full</code>, se debe proporcionar un certificado de CA a trav\u00e9s de <code>--pg-sslcert</code> o <code>FAUCET_TELEMETRY_POSTGRES_SSLCERT</code>.</p>"},{"location":"es/options/#opciones-del-subcomando-start","title":"Opciones del Subcomando <code>start</code>","text":"<p>Estas opciones son espec\u00edficas del subcomando <code>start</code>, utilizado para ejecutar un servidor faucet est\u00e1ndar.</p>"},{"location":"es/options/#workers","title":"Workers","text":"<ul> <li>CLI: <code>--workers</code> o <code>-w</code></li> <li>Entorno: <code>FAUCET_WORKERS</code></li> <li>Predeterminado: El n\u00famero de CPUs disponibles para el proceso</li> </ul> <p>El n\u00famero de procesos de trabajo a generar. En una carga de trabajo limitada por la CPU, esto deber\u00eda establecerse en el n\u00famero de CPUs disponibles para el proceso. En una carga de trabajo limitada por E/S, esto podr\u00eda establecerse en un n\u00famero mayor.</p>"},{"location":"es/options/#strategy","title":"Strategy","text":"<ul> <li>CLI: <code>--strategy</code> o <code>-s</code></li> <li>Entorno: <code>FAUCET_STRATEGY</code></li> <li>Predeterminado: <code>round-robin</code></li> <li>Valores posibles:</li> <li><code>round-robin</code></li> <li><code>ip-hash</code></li> <li><code>cookie-hash</code></li> </ul> <p>La estrategia a utilizar para el balanceo de carga. La estrategia que elijas depende de tu carga de trabajo.</p>"},{"location":"es/options/#round-robin","title":"Round Robin","text":"<p>Round robin es una estrategia de balanceo de carga muy ligera y simple. Simplemente distribuye las solicitudes a los workers de manera rotativa. Esta puede ser una buena estrategia para la mayor\u00eda de las cargas de trabajo, es muy simple y tiene muy poca sobrecarga.</p> <p>NO deber\u00edas usar round robin si el servidor es con estado (stateful), ya que no garantizar\u00e1 que las solicitudes del mismo cliente se dirijan al mismo worker. Si necesitas un estado persistente, usa IP Hash o Cookie Hash.</p> <p>Si un worker muere, las solicitudes que se estaban enrutando continuar\u00e1n hacia el siguiente worker disponible que est\u00e9 vivo.</p>"},{"location":"es/options/#ip-hash","title":"IP Hash","text":"<p>IP Hash es una estrategia m\u00e1s compleja que garantiza que las solicitudes del mismo cliente se dirijan al mismo worker. Esto es \u00fatil para servidores con estado, como las aplicaciones Shiny. IP Hash se aplica en las aplicaciones Shiny si la estrategia se establece en <code>auto</code>.</p> <p>Si un worker muere, las solicitudes se retendr\u00e1n hasta que el worker vuelva a estar en l\u00ednea. Esto significa que la latencia puede aumentar si un worker muere.</p>"},{"location":"es/options/#cookie-hash","title":"Cookie Hash","text":"<p>Cookie Hash utiliza una cookie para identificar al worker al que se debe enviar la solicitud. Esto es \u00fatil para sesiones persistentes (sticky sessions) desde la misma red, incluso si los clientes est\u00e1n detr\u00e1s de un NAT o comparten la misma direcci\u00f3n IP.</p>"},{"location":"es/options/#type-tipo-de-servidor","title":"Type (Tipo de servidor)","text":"<ul> <li>CLI: <code>--type</code> o <code>-t</code></li> <li>Entorno: <code>FAUCET_TYPE</code></li> <li>Predeterminado: <code>auto</code></li> <li>Valores posibles:</li> <li><code>auto</code></li> <li><code>plumber</code></li> <li><code>shiny</code></li> <li><code>quarto-shiny</code></li> <li><code>fast-api</code></li> </ul> <p>El tipo de servidor a ejecutar. Se utiliza para determinar la estrategia correcta a usar y c\u00f3mo generar los workers.</p>"},{"location":"es/options/#auto","title":"Auto","text":"<p>Auto intentar\u00e1 determinar el tipo de servidor bas\u00e1ndose en el contenido del directorio especificado por <code>--dir</code>.</p> <ul> <li>Si el directorio contiene un archivo <code>plumber.R</code> o <code>entrypoint.R</code>, se asumir\u00e1 que es un servidor Plumber.</li> <li>Si el directorio contiene un archivo <code>app.R</code>, o ambos archivos <code>server.R</code> y <code>ui.R</code>, se asumir\u00e1 que es un servidor Shiny.</li> <li>Si se proporciona un archivo <code>.qmd</code> a trav\u00e9s del argumento <code>--qmd</code>, o si <code>FAUCET_QMD</code> est\u00e1 establecido, se asumir\u00e1 que es una aplicaci\u00f3n Quarto Shiny.   De lo contrario, faucet saldr\u00e1 con un error.</li> </ul>"},{"location":"es/options/#plumber","title":"Plumber","text":"<p>Ejecuta el servidor como una API de Plumber. La estrategia predeterminada es <code>round-robin</code>.</p>"},{"location":"es/options/#shiny","title":"Shiny","text":"<p>Ejecuta el servidor como una aplicaci\u00f3n Shiny. La estrategia predeterminada es <code>ip-hash</code>.</p>"},{"location":"es/options/#quarto-shiny","title":"Quarto Shiny","text":"<p>Ejecuta el servidor como una aplicaci\u00f3n Quarto Shiny. La estrategia predeterminada es <code>ip-hash</code>. Requiere la opci\u00f3n <code>--qmd</code> para especificar el documento Quarto.</p>"},{"location":"es/options/#fastapi","title":"FastAPI","text":"<p>Ejecuta el servidor como una aplicaci\u00f3n FastAPI. La estrategia predeterminada es <code>round-robin</code>. Esto requiere que <code>uv</code> est\u00e9 instalado. Faucet buscar\u00e1 un archivo <code>main.py</code> en el directorio especificado y lo servir\u00e1.</p>"},{"location":"es/options/#directory-directorio-de-trabajo","title":"Directory (Directorio de trabajo)","text":"<ul> <li>CLI: <code>--dir</code> o <code>-d</code></li> <li>Entorno: <code>FAUCET_DIR</code></li> <li>Predeterminado: <code>.</code></li> </ul> <p>El directorio desde el cual ejecutar el servidor. Este debe ser el directorio que contiene el <code>plumber.R</code> o el contenido de la aplicaci\u00f3n Shiny.</p>"},{"location":"es/options/#app-directory-appdir-de-shiny","title":"App Directory (<code>appDir</code> de Shiny)","text":"<ul> <li>CLI: <code>--app-dir</code> o <code>-a</code></li> <li>Entorno: <code>FAUCET_APP_DIR</code></li> <li>Predeterminado: <code>None</code></li> </ul> <p>Argumento pasado a <code>appDir</code> al ejecutar aplicaciones Shiny. Esto te permite especificar un subdirectorio dentro de la ruta <code>--dir</code> como la ra\u00edz para la aplicaci\u00f3n Shiny.</p>"},{"location":"es/options/#qmd-documento-quarto","title":"QMD (Documento Quarto)","text":"<ul> <li>CLI: <code>--qmd</code></li> <li>Entorno: <code>FAUCET_QMD</code></li> <li>Predeterminado: <code>None</code></li> </ul> <p>Ruta al archivo <code>.qmd</code> de Quarto Shiny. Esto es requerido cuando <code>type</code> se establece en <code>quarto-shiny</code>, o cuando <code>type</code> es <code>auto</code> y tienes la intenci\u00f3n de ejecutar una aplicaci\u00f3n Quarto Shiny.</p>"},{"location":"es/options/#opciones-del-subcomando-router","title":"Opciones del Subcomando <code>router</code>","text":"<p>Estas opciones son espec\u00edficas del subcomando <code>router</code>, utilizado para ejecutar faucet en modo router (experimental).</p>"},{"location":"es/options/#config-file","title":"Config File","text":"<ul> <li>CLI: <code>--conf</code> o <code>-c</code></li> <li>Entorno: <code>FAUCET_ROUTER_CONF</code></li> <li>Predeterminado: <code>./frouter.toml</code></li> </ul> <p>Ruta al archivo de configuraci\u00f3n TOML del router.</p>"},{"location":"es/options/#subcomando-rscript","title":"Subcomando <code>rscript</code>","text":"<p>Este subcomando te permite ejecutar un script de R arbitrario. Cualquier argumento que siga a <code>rscript</code> se pasar\u00e1 directamente al ejecutable <code>Rscript</code>.</p> <p>Ejemplo: <code>faucet rscript mi_script.R --arg1 valor1</code></p>"},{"location":"es/options/#subcomando-uv","title":"Subcomando <code>uv</code>","text":"<p>Este subcomando te permite ejecutar comandos <code>uv</code> arbitrarios. Esto es particularmente \u00fatil para ejecutar scripts de Python o gestionar entornos de Python. Cualquier argumento que siga a <code>uv</code> se pasar\u00e1 directamente al ejecutable <code>uv</code>.</p> <p>Ejemplo: <code>faucet uv run mi_script.py</code> o <code>faucet uv pip install pandas</code></p>"},{"location":"es/reverse_proxy/","title":"Con Proxy Inverso","text":"<p>Puede que quieras usar faucet con un proxy inverso como Nginx o Apache. Esto puede ser \u00fatil si deseas agregar enrutamiento, SSL u otras caracter\u00edsticas \u00fatiles de un proxy inverso. Esta p\u00e1gina te mostrar\u00e1 algunas de las configuraciones necesarias para que faucet funcione con un proxy inverso.</p>"},{"location":"es/reverse_proxy/#nginx","title":"Nginx","text":"<p>Para tu configuraci\u00f3n de nginx, podr\u00edas querer agregar lo siguiente a tu bloque <code>location</code>:</p> <pre><code>proxy_set_header Upgrade $http_upgrade;\nproxy_set_header Connection $connection_upgrade;\nproxy_set_header  X-Real-IP $remote_addr;\nproxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;\nproxy_http_version 1.1;\n</code></pre> <p>En este caso estamos agregando los encabezados <code>Upgrade</code> y <code>Connection</code> para que la conexi\u00f3n de websocket funcione. Tambi\u00e9n estamos agregando los encabezados <code>X-Real-IP</code> y <code>X-Forwarded-For</code> para que la direcci\u00f3n IP del cliente sea reenviada a faucet.</p> <p>faucet necesitar\u00e1 estar configurado para confiar en el proxy y usar ya sea el encabezado <code>X-Real-IP</code> o <code>X-Forwarded-For</code> para obtener la direcci\u00f3n IP del cliente. Esto se puede hacer agregando las opciones de l\u00ednea de comandos <code>--ip-from</code> / <code>-i</code> o estableciendo la variable de entorno <code>FAUCET_IP_FROM</code>.</p> <p>Para usar el encabezado <code>X-Real-IP</code>, establece la variable de entorno <code>FAUCET_IP_FROM</code> a <code>x-real-ip</code>. Para usar el encabezado <code>X-Forwarded-For</code>, establece la variable de entorno <code>FAUCET_IP_FROM</code> a <code>x-forwarded-for</code>.</p>"},{"location":"es/reverse_proxy/#apache","title":"Apache","text":"<p>Para tu configuraci\u00f3n de apache, podr\u00edas querer agregar lo siguiente a tu bloque <code>VirtualHost</code>:</p> <pre><code>RewriteEngine on\nRewriteCond %{HTTP:Upgrade} =websocket\nRewriteRule /(.*) ws://localhost:3838/$1 [P,L]\nRewriteCond %{HTTP:Upgrade} !=websocket\nRewriteRule /(.*) http://localhost:3838/$1 [P,L]\n</code></pre> <p>Apache agrega autom\u00e1ticamente el encabezado <code>X-Fowarded-For</code>, as\u00ed que no necesitas hacer nada m\u00e1s para que la direcci\u00f3n IP del cliente llegue a faucet. Necesitar\u00e1s establecer la variable de entorno <code>FAUCET_IP_FROM</code> a <code>x-forwarded-for</code> para que faucet utilice el encabezado <code>X-Forwarded-For</code> para obtener la direcci\u00f3n IP del cliente. Tambi\u00e9n puedes usar la opci\u00f3n de l\u00ednea de comandos <code>--ip-from</code> / <code>-i</code> para establecer la variable de entorno <code>FAUCET_IP_FROM</code>.</p>"},{"location":"es/router/","title":"Modo Router de Faucet","text":"<p>El modo router de Faucet te permite servir m\u00faltiples aplicaciones distintas desde una \u00fanica instancia de Faucet. Cada aplicaci\u00f3n, o \"ruta\", puede tener su propia configuraci\u00f3n (como tipo de aplicaci\u00f3n, directorio de trabajo, n\u00famero de workers y estrategia de balanceo de carga) y es accesible a trav\u00e9s de un prefijo de ruta URL \u00fanico.</p> <p>Esto es particularly \u00fatil para:</p> <ul> <li>Alojar m\u00faltiples aplicaciones Shiny, APIs de Plumber o documentos Quarto Shiny en el mismo servidor y puerto.</li> <li>Desplegar diferentes versiones o configuraciones de la misma aplicaci\u00f3n bajo diferentes rutas.</li> <li>Consolidar tus despliegues de aplicaciones R en un \u00fanico proceso de Faucet.</li> </ul>"},{"location":"es/router/#resumen-en-video","title":"Resumen en Video","text":"<p>Para una demostraci\u00f3n visual de la caracter\u00edstica del router de Faucet, revisa el siguiente video:</p>"},{"location":"es/router/#activacion-del-modo-router","title":"Activaci\u00f3n del Modo Router","text":"<p>Para ejecutar Faucet en modo router, utilizas el subcomando <code>router</code>:</p> <pre><code>faucet router [OPCIONES]\n</code></pre> <p>La opci\u00f3n principal para el modo router es especificar el archivo de configuraci\u00f3n:</p> <ul> <li>CLI: <code>--conf &lt;RUTA_AL_ARCHIVO_DE_CONFIGURACION&gt;</code> o <code>-c &lt;RUTA_AL_ARCHIVO_DE_CONFIGURACION&gt;</code></li> <li>Variable de Entorno: <code>FAUCET_ROUTER_CONF=&lt;RUTA_AL_ARCHIVO_DE_CONFIGURACION&gt;</code></li> <li>Por Defecto: Si no se especifica, Faucet buscar\u00e1 un archivo llamado <code>frouter.toml</code> en el directorio de trabajo actual (<code>./frouter.toml</code>).</li> </ul> <p>Las opciones globales de Faucet como <code>--host</code>, <code>--ip-from</code>, <code>--rscript</code>, <code>--quarto</code> y las configuraciones de telemetr\u00eda (por ejemplo, <code>--pg-con-string</code>) se aplican a toda la instancia del router y a todas las rutas que gestiona.</p>"},{"location":"es/router/#archivo-de-configuracion-froutertoml","title":"Archivo de Configuraci\u00f3n (<code>frouter.toml</code>)","text":"<p>El modo router se configura mediante un archivo TOML. Este archivo debe definir un array llamado <code>route</code>, donde cada elemento del array es un objeto que configura una ruta de aplicaci\u00f3n espec\u00edfica.</p> <p>Aqu\u00ed est\u00e1 la estructura de un \u00fanico objeto de ruta dentro del archivo <code>frouter.toml</code>:</p> <pre><code>[[route]]\n# El prefijo de la ruta URL para esta aplicaci\u00f3n.\n# Este prefijo DEBE terminar con una barra inclinada (ej., \"/app/\", \"/api/v1/\").\n# Si es la ruta ra\u00edz, debe ser \"/\".\n# (Requerido)\nroute = \"/mi_aplicacion/\"\n\n# El tipo de aplicaci\u00f3n.\n# (Requerido)\n# Posibles valores: \"plumber\", \"shiny\", \"quarto-shiny\"\n# Alias como \"Plumber\", \"Shiny\", \"QuartoShiny\" tambi\u00e9n son aceptados.\nserver_type = \"shiny\"\n\n# El directorio de trabajo para esta aplicaci\u00f3n espec\u00edfica.\n# Archivos como app.R o plumber.R se buscar\u00e1n en relaci\u00f3n con este directorio,\n# o dentro de `app_dir` si se especifica. Las rutas pueden ser relativas (a donde est\u00e1 frouter.toml) o absolutas.\n# (Opcional, por defecto es \".\" - el directorio donde se encuentra frouter.toml)\nworkdir = \"./apps/mi_app_shiny\"\n\n# El subdirectorio dentro de `workdir` donde se encuentra el archivo principal de la aplicaci\u00f3n (ej., app.R).\n# Si tu app.R est\u00e1 directamente en `workdir`, puedes omitir esto o configurarlo como \".\".\n# (Opcional)\napp_dir = \"source\" # Busca ./apps/mi_app_shiny/source/app.R\n\n# El n\u00famero de procesos worker a generar para esta aplicaci\u00f3n.\n# (Requerido)\nworkers = 2\n\n# La estrategia de balanceo de carga para esta aplicaci\u00f3n.\n# (Opcional, los valores por defecto dependen del tipo de aplicaci\u00f3n: \"ip-hash\" para shiny/quarto-shiny, \"round-robin\" para plumber)\n# Posibles valores: \"round-robin\", \"ip-hash\", \"cookie-hash\"\nstrategy = \"ip-hash\"\n\n# Ruta al documento Quarto (.qmd), requerido si server_type es \"quarto-shiny\".\n# La ruta debe ser relativa a `workdir` o una ruta absoluta.\n# (Opcional, pero requerido para quarto-shiny)\n# qmd = \"dashboard.qmd\"\n</code></pre>"},{"location":"es/router/#campos-explicados","title":"Campos Explicados:","text":"<ul> <li><code>route</code> (String, Requerido): El prefijo de la ruta URL. Este prefijo debe terminar con una barra inclinada (ej., <code>/app/</code>, <code>/api/v1/</code>) a menos que sea la ruta ra\u00edz (<code>/</code>). Faucet dirigir\u00e1 las solicitudes que comiencen con esta ruta a la aplicaci\u00f3n configurada.</li> <li><code>server_type</code> (String, Requerido): Determina el tipo de aplicaci\u00f3n R. Debe ser uno de <code>plumber</code>, <code>shiny</code> o <code>quarto-shiny</code>. Alias como <code>Plumber</code>, <code>Shiny</code>, <code>QuartoShiny</code> tambi\u00e9n son aceptados.</li> <li><code>workdir</code> (String, Opcional): El directorio de trabajo base para la aplicaci\u00f3n. Si no se especifica, por defecto es el directorio donde se est\u00e1 ejecutando Faucet (t\u00edpicamente donde se encuentra <code>frouter.toml</code>). Las rutas para <code>app_dir</code> y <code>qmd</code> se resuelven t\u00edpicamente en relaci\u00f3n con este.</li> <li><code>app_dir</code> (String, Opcional): Un subdirectorio dentro de <code>workdir</code> que contiene el archivo principal de la aplicaci\u00f3n (por ejemplo, <code>app.R</code> para Shiny, <code>plumber.R</code> para Plumber). Por ejemplo, si <code>workdir = \"./mi_coleccion_apps\"</code> y <code>app_dir = \"app_especifica_src\"</code>, Faucet buscar\u00e1 <code>./mi_coleccion_apps/app_especifica_src/app.R</code>. Si el archivo principal est\u00e1 directamente en <code>workdir</code>, puedes omitir esto o usar <code>app_dir = \".\"</code>.</li> <li><code>workers</code> (Integer, Requerido): El n\u00famero de procesos worker de R a lanzar para esta ruta espec\u00edfica. Debe ser un entero positivo.</li> <li><code>strategy</code> (String, Opcional): La estrategia de balanceo de carga para esta ruta.<ul> <li>Para aplicaciones <code>shiny</code> y <code>quarto-shiny</code>, generalmente se recomienda <code>ip-hash</code> y es el valor por defecto para asegurar la persistencia de la sesi\u00f3n.</li> <li>Para APIs <code>plumber</code>, <code>round-robin</code> es el valor por defecto com\u00fan.</li> <li>Opciones disponibles: <code>round-robin</code>, <code>ip-hash</code>, <code>cookie-hash</code>.</li> </ul> </li> <li><code>qmd</code> (String, Opcional): Si <code>server_type</code> es <code>quarto-shiny</code>, este campo es requerido y debe especificar la ruta al archivo <code>.qmd</code>. Esta ruta es t\u00edpicamente relativa a <code>workdir</code>.</li> </ul> <p>Importante: Cada valor de <code>route</code> en el archivo de configuraci\u00f3n debe ser \u00fanico. Rutas duplicadas har\u00e1n que Faucet termine con un error al iniciarse.</p>"},{"location":"es/router/#comportamiento-del-enrutamiento-y-eliminacion-de-prefijo-de-ruta-path-stripping","title":"Comportamiento del Enrutamiento y Eliminaci\u00f3n de Prefijo de Ruta (Path Stripping)","text":"<p>Cuando Faucet recibe una solicitud HTTP en modo router:</p> <ol> <li>Itera a trav\u00e9s de las definiciones <code>[[route]]</code> en <code>frouter.toml</code> en el orden en que est\u00e1n definidas.</li> <li>Coincidencia de Rutas y Orden:<ul> <li>Para cada ruta definida, Faucet comprueba si la ruta URL de la solicitud entrante comienza con el prefijo <code>route</code> de la ruta.</li> <li>Se utiliza la primera ruta que coincida. Esto significa que el orden de tus rutas en <code>frouter.toml</code> es cr\u00edtico. Las rutas m\u00e1s espec\u00edficas (ej., <code>/app/feature1/</code>) deben listarse antes que las rutas m\u00e1s generales (ej., <code>/app/</code>) si comparten una ruta base com\u00fan, para evitar que la ruta general \"sombre\u00e9\" a la espec\u00edfica. La ruta ra\u00edz <code>/</code> generalmente debe listarse al final.</li> </ul> </li> <li>Eliminaci\u00f3n de Prefijo de Ruta (Path Stripping):<ul> <li>Todos los prefijos <code>route</code> (excepto la ruta ra\u00edz <code>/</code>) deben terminar con una barra inclinada (<code>/</code>).</li> <li>Una vez que se encuentra una ruta coincidente, su prefijo <code>route</code> definido se elimina del inicio de la ruta URL de la solicitud.</li> <li>La parte restante de la ruta se reenv\u00eda entonces a la aplicaci\u00f3n configurada para esa ruta.</li> <li>Ejemplo: Si se define <code>route = \"/myapp/\"</code>:<ul> <li>Una solicitud a <code>/myapp/usuarios/1</code> hace que la aplicaci\u00f3n vea <code>/usuarios/1</code>.</li> <li>Una solicitud a <code>/myapp/</code> (con la barra inclinada final) hace que la aplicaci\u00f3n vea <code>/</code>.</li> </ul> </li> <li>Ejemplo: Si se define <code>route = \"/\"</code>:<ul> <li>Una solicitud a <code>/pagina</code> hace que la aplicaci\u00f3n vea <code>/pagina</code>.</li> <li>Una solicitud a <code>/</code> hace que la aplicaci\u00f3n vea <code>/</code>.</li> </ul> </li> </ul> </li> <li>Si se encuentra una ruta coincidente, la solicitud (con la ruta potencialmente modificada) se entrega a la instancia del servidor Faucet que gestiona esa aplicaci\u00f3n espec\u00edfica, la cual luego aplica su estrategia de balanceo de carga configurada para seleccionar un worker.</li> <li>Si ninguna <code>route</code> configurada coincide con la ruta de la solicitud entrante, Faucet devuelve una respuesta <code>404 Not Found</code>.</li> </ol>"},{"location":"es/router/#ejemplo-de-froutertoml","title":"Ejemplo de <code>frouter.toml</code>","text":"<p>Este ejemplo se basa en <code>faucet-router-example</code> disponible en el repositorio de GitHub de Faucet bajo el directorio <code>examples/</code>. Para ejecutar este ejemplo, navega a <code>examples/faucet-router-example-main/</code> y ejecuta <code>faucet router</code>.</p> <pre><code># frouter.toml\n# Este archivo est\u00e1 ubicado en examples/faucet-router-example-main/\n\n# Ruta para la aplicaci\u00f3n Shiny \"sliders\".\n# `workdir` est\u00e1 configurado como \"./sliders\", entonces Faucet busca app.R\n# en examples/faucet-router-example-main/sliders/app.R\n[[route]]\nroute = \"/sliders/\"\nworkers = 1\nserver_type = \"shiny\" # Nota: \"Shiny\" (con may\u00fascula) tambi\u00e9n es aceptado\nworkdir = \"./sliders\"\n\n# Ruta para la aplicaci\u00f3n Shiny \"text\".\n# `workdir` por defecto es \".\" (donde est\u00e1 frouter.toml).\n# `app_dir` es \"./text\", entonces Faucet busca app.R\n# en examples/faucet-router-example-main/text/app.R\n[[route]]\nroute = \"/text/\"\nworkers = 1\nserver_type = \"shiny\"\napp_dir = \"./text\"\n\n# Ruta para un documento Quarto Shiny.\n# `workdir` es \"./qmd\".\n# `qmd` especifica \"old_faithful.qmd\" relativo a workdir.\n# Faucet busca examples/faucet-router-example-main/qmd/old_faithful.qmd\n[[route]]\nroute = \"/qmd/\"\nworkers = 1\nserver_type = \"quarto-shiny\" # Nota: \"QuartoShiny\" (con may\u00fascula) tambi\u00e9n es aceptado\nworkdir = \"./qmd\"\nqmd = \"old_faithful.qmd\"\n\n# Ruta para una API de Plumber.\n# `workdir` es \"./api\". Faucet busca plumber.R\n# en examples/faucet-router-example-main/api/plumber.R\n[[route]]\nroute = \"/api/\"\nworkers = 1\nserver_type = \"plumber\" # Nota: \"Plumber\" (con may\u00fascula) tambi\u00e9n es aceptado\nworkdir = \"./api\"\nstrategy = \"round-robin\"\n\n# Ruta ra\u00edz para la aplicaci\u00f3n Shiny principal.\n# `workdir` por defecto es \".\" (donde est\u00e1 frouter.toml).\n# Faucet busca app.R en examples/faucet-router-example-main/app.R\n# Esta ruta se coloca al final para evitar solapar otras rutas espec\u00edficas.\n[[route]]\nroute = \"/\"\nworkers = 1\nserver_type = \"shiny\"\nstrategy = \"cookie-hash\"\n</code></pre> <p>Con la configuraci\u00f3n anterior, si Faucet se est\u00e1 ejecutando en <code>http://localhost:3838</code> desde el directorio <code>examples/faucet-router-example-main/</code>:</p> <ul> <li>Las solicitudes a <code>http://localhost:3838/sliders/</code> ser\u00edan enrutadas a la aplicaci\u00f3n Shiny en el subdirectorio <code>sliders</code>.</li> <li>Las solicitudes a <code>http://localhost:3838/text/</code> ser\u00edan enrutadas a la aplicaci\u00f3n Shiny en el subdirectorio <code>text</code>.</li> <li>Las solicitudes a <code>http://localhost:3838/qmd/</code> ser\u00edan enrutadas al documento Quarto Shiny <code>old_faithful.qmd</code>.</li> <li>Las solicitudes a <code>http://localhost:3838/api/echo?msg=hola</code> ser\u00edan enrutadas a la API de Plumber en el subdirectorio <code>api</code> (la API ver\u00eda <code>/echo?msg=hola</code>).</li> <li>Las solicitudes a <code>http://localhost:3838/</code> ser\u00edan enrutadas al <code>app.R</code> en la ra\u00edz del directorio <code>faucet-router-example-main</code>.</li> </ul> <p>Nota sobre el Orden de las Rutas: Recuerda que si tienes rutas con rutas base superpuestas (ej., <code>/datos/especifico/</code> y <code>/datos/</code>), debes listar la ruta m\u00e1s espec\u00edfica (<code>/datos/especifico/</code>) antes que la ruta m\u00e1s general (<code>/datos/</code>) en tu archivo <code>frouter.toml</code>. De lo contrario, la ruta general <code>/datos/</code> coincidir\u00eda con las solicitudes destinadas a <code>/datos/especifico/</code>, y nunca se alcanzar\u00eda la ruta espec\u00edfica. La ruta ra\u00edz <code>/</code> t\u00edpicamente deber\u00eda ser la \u00faltima entrada.</p> <p>Este modo router proporciona una forma flexible de gestionar y servir m\u00faltiples aplicaciones R eficientemente usando una \u00fanica instancia de Faucet.</p>"},{"location":"es/telemetry/","title":"Telemetr\u00eda en Faucet","text":"<p>Faucet incluye una funci\u00f3n de telemetr\u00eda dise\u00f1ada para ayudarte a monitorear el rendimiento y los patrones de uso de tus aplicaciones desplegadas. Cuando est\u00e1 habilitada, Faucet puede enviar datos de telemetr\u00eda a una base de datos PostgreSQL, permitiendo el an\u00e1lisis y la obtenci\u00f3n de informaci\u00f3n sobre c\u00f3mo est\u00e1n operando tus instancias de Faucet y las aplicaciones R subyacentes.</p> <p>Este documento describe c\u00f3mo configurar y utilizar las capacidades de telemetr\u00eda de Faucet.</p>"},{"location":"es/telemetry/#configuracion-de-la-base-de-datos","title":"Configuraci\u00f3n de la Base de Datos","text":"<p>Antes de habilitar la telemetr\u00eda, necesitas configurar tu base de datos PostgreSQL con la tabla requerida. Faucet enviar\u00e1 sus datos de telemetr\u00eda a una tabla llamada <code>faucet_http_events</code>.</p> <p>Puedes crear esta tabla usando el siguiente comando SQL:</p> <pre><code>CREATE TABLE faucet_http_events (\n    request_uuid UUID,\n    namespace TEXT,\n    version TEXT,\n    target TEXT,\n    worker_route TEXT,\n    worker_id INT,\n    ip_addr INET,\n    method TEXT,\n    path TEXT,\n    query_params TEXT,\n    http_version TEXT,\n    status SMALLINT,\n    user_agent TEXT,\n    elapsed BIGINT,\n    time TIMESTAMPTZ NOT NULL\n);\n</code></pre> <p>Nota para Usuarios de TimescaleDB:</p> <p>Si est\u00e1s utilizando TimescaleDB, opcionalmente puedes convertir esta tabla en una hypertable para una mejor gesti\u00f3n de datos de series temporales. Despu\u00e9s de crear la tabla como se muestra arriba, puedes ejecutar el siguiente comando SQL:</p> <pre><code>SELECT create_hypertable('faucet_http_events', by_range('time'));\n</code></pre> <p>Este paso es espec\u00edfico para TimescaleDB y mejora sus capacidades para manejar grandes vol\u00famenes de datos de series temporales.</p>"},{"location":"es/telemetry/#habilitacion-y-configuracion-de-la-telemetria","title":"Habilitaci\u00f3n y Configuraci\u00f3n de la Telemetr\u00eda","text":"<p>La telemetr\u00eda en Faucet est\u00e1 deshabilitada por defecto. Para habilitarla, debes proporcionar una cadena de conexi\u00f3n de PostgreSQL. La configuraci\u00f3n se puede realizar mediante opciones de l\u00ednea de comandos o variables de entorno.</p>"},{"location":"es/telemetry/#opciones-clave-de-configuracion","title":"Opciones Clave de Configuraci\u00f3n:","text":"<ol> <li> <p>Cadena de Conexi\u00f3n de PostgreSQL:</p> <ul> <li>CLI: <code>--telemetry-postgres-string &lt;CADENA_DE_CONEXION&gt;</code></li> <li>Variable de Entorno: <code>FAUCET_TELEMETRY_POSTGRES_STRING=&lt;CADENA_DE_CONEXION&gt;</code></li> <li>Descripci\u00f3n: Esta es la configuraci\u00f3n esencial para habilitar la telemetr\u00eda. La cadena de conexi\u00f3n debe estar en un formato adecuado para conectarse a tu base de datos PostgreSQL (por ejemplo, <code>postgresql://usuario:contrase\u00f1a@host:puerto/basededatos</code>). Faucet utilizar\u00e1 esto para enviar datos de telemetr\u00eda.</li> <li>Por Defecto: <code>None</code> (Telemetr\u00eda deshabilitada)</li> </ul> </li> <li> <p>Espacio de Nombres de Telemetr\u00eda (Namespace):</p> <ul> <li>CLI: <code>--telemetry-namespace &lt;NAMESPACE&gt;</code></li> <li>Variable de Entorno: <code>FAUCET_TELEMETRY_NAMESPACE=&lt;NAMESPACE&gt;</code></li> <li>Descripci\u00f3n: Te permite definir un espacio de nombres para los datos de telemetr\u00eda. Esto es \u00fatil si est\u00e1s recopilando datos de m\u00faltiples instancias de Faucet o diferentes servicios en la misma base de datos, ayudando a segmentar e identificar la fuente de los datos.</li> <li>Por Defecto: <code>faucet</code></li> </ul> </li> <li> <p>Versi\u00f3n de Telemetr\u00eda:</p> <ul> <li>CLI: <code>--telemetry-version &lt;VERSION&gt;</code></li> <li>Variable de Entorno: <code>FAUCET_TELEMETRY_VERSION=&lt;VERSION&gt;</code></li> <li>Descripci\u00f3n: Especifica la versi\u00f3n del servicio o aplicaci\u00f3n que est\u00e1 siendo ejecutada/monitoreada por Faucet. Puede ser la versi\u00f3n de tu aplicaci\u00f3n o la versi\u00f3n de Faucet misma. Es \u00fatil para filtrar datos de telemetr\u00eda y correlacionar observaciones con despliegues espec\u00edficos.</li> <li>Por Defecto: <code>None</code></li> </ul> </li> </ol> <p>Para m\u00e1s detalles sobre estas opciones, consulta la p\u00e1gina de Opciones de L\u00ednea de Comandos.</p>"},{"location":"es/telemetry/#datos-recopilados","title":"Datos Recopilados","text":"<p>El sistema de telemetr\u00eda de Faucet est\u00e1 dise\u00f1ado para capturar informaci\u00f3n relevante para los aspectos operativos del servidor y las aplicaciones que gestiona. Aunque el esquema exacto y los puntos de datos pueden evolucionar, las categor\u00edas generales de datos recopilados incluyen:</p> <ul> <li>M\u00e9tricas de Solicitud/Respuesta: Informaci\u00f3n sobre las solicitudes HTTP entrantes y las respuestas generadas, como rutas de solicitud, c\u00f3digos de estado de respuesta y latencias.</li> <li>Rendimiento del Worker: Datos relacionados con el comportamiento de los procesos worker individuales, incluyendo potencialmente tiempos de procesamiento y tasas de error.</li> <li>Eventos de Balanceo de Carga: Informaci\u00f3n sobre c\u00f3mo se distribuyen las solicitudes si se utilizan estrategias de balanceo de carga.</li> <li>Informaci\u00f3n de la Instancia: Detalles como el espacio de nombres y la versi\u00f3n configurados, para ayudar a contextualizar los datos.</li> </ul> <p>Los datos se estructuran para ser almacenados en una base de datos PostgreSQL, lo que permite consultas basadas en SQL e integraci\u00f3n con diversas herramientas de an\u00e1lisis y visualizaci\u00f3n.</p>"},{"location":"es/telemetry/#utilizacion-de-los-datos-de-telemetria","title":"Utilizaci\u00f3n de los Datos de Telemetr\u00eda","text":"<p>Una vez que la telemetr\u00eda est\u00e1 configurada y Faucet est\u00e1 enviando datos a tu base de datos PostgreSQL, puedes:</p> <ul> <li>Monitorear la Salud de la Aplicaci\u00f3n: Rastrear tasas de error, tiempos de respuesta y otros indicadores clave de rendimiento (KPIs) para asegurar que tus aplicaciones funcionen sin problemas.</li> <li>Entender Patrones de Uso: Analizar vol\u00famenes de solicitudes, puntos finales populares y actividad del usuario para obtener informaci\u00f3n sobre c\u00f3mo se est\u00e1n utilizando tus aplicaciones.</li> <li>Solucionar Problemas: Correlacionar datos de telemetr\u00eda con registros y otras herramientas de monitoreo para diagnosticar y resolver problemas de manera m\u00e1s efectiva.</li> <li>Planificaci\u00f3n de Capacidad: Observar la utilizaci\u00f3n de recursos y las tendencias de rendimiento a lo largo del tiempo para tomar decisiones informadas sobre el escalado de tu infraestructura.</li> <li>Optimizaci\u00f3n del Rendimiento: Identificar cuellos de botella u operaciones lentas examinando las latencias de las solicitudes y los datos de rendimiento de los workers.</li> </ul> <p>Puedes conectarte a la base de datos PostgreSQL utilizando clientes SQL est\u00e1ndar, herramientas de inteligencia de negocios o scripts personalizados para consultar y visualizar los datos de telemetr\u00eda recopilados seg\u00fan tus necesidades.</p>"}]}